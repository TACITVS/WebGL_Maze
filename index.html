<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Procedural Maze Â· Special Zones</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:'Arial',sans-serif;}
    canvas{display:block}
    
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 100;
      color: #fff;
    }
    
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      pointer-events: auto;
      font-size: 14px;
      max-width: 250px;
    }

    #hud {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 30px;
        background: rgba(0,0,0,0.7);
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 22px;
        font-weight: bold;
        text-shadow: 1px 1px 2px #000;
    }
    
    #powerup-status {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 150, 255, 0.8);
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 18px;
        font-weight: bold;
        text-shadow: 1px 1px 2px #000;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
    }
    
    #minimap-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      border: 3px solid #444;
      border-radius: 8px;
      background: rgba(0,0,0,0.9);
      pointer-events: auto;
    }
    
    #minimap {
      display: block;
      border-radius: 5px;
    }
    
    #camera-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
    }
    
    #goal-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff00;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    #physics-debug {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      display: none;
    }
    .control-key {
      background: rgba(255,255,255,0.2);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      cursor: pointer;
      display: inline-block;
      min-width: 12px;
      text-align: center;
    }
    .muted {
        text-decoration: line-through;
        opacity: 0.5;
    }
  </style>
</head>
<body>
<div id="ui">
  <div id="hud">
    <div>Time: <span id="timer">00:00</span></div>
    <div>Score: <span id="score">0</span></div>
  </div>

  <div id="controls">
    <div><strong>ðŸŽ® Controls</strong></div>
    <div><span class="control-key">WASD</span> / <span class="control-key">Arrows</span> - Move</div>
    <div><span class="control-key">C</span> - Switch Camera</div>
    <div><span class="control-key">M</span> - Toggle Minimap</div>
    <div><span class="control-key">R</span> - New Maze</div>
    <div><span class="control-key">P</span> - Physics Debug</div>
    
    <div style="margin-top:10px;"><strong>ðŸ”Š Audio</strong></div>
    <div><span class="control-key" id="toggle-music">J</span> - Music</div>
    <div><span class="control-key" id="toggle-sfx">K</span> - SFX</div>

    <div style="margin-top:10px;"><strong>ðŸŽ¯ Goal:</strong> Find the green exit!</div>
    <div style="margin-top:5px;font-size:11px;opacity:0.8;">
      <em>Collect coins for more points!</em>
    </div>
  </div>
  
  <div id="camera-info">Third Person</div>
  <div id="powerup-status">SPEED BOOST!</div>
  
  <div id="minimap-container">
    <canvas id="minimap" width="200" height="200"></canvas>
  </div>
  
  <div id="goal-indicator">ðŸŽ‰ MAZE COMPLETED! ðŸŽ‰</div>
  
  <div id="physics-debug">
    <div><strong>Physics Debug</strong></div>
    <div>Speed: <span id="debug-speed">0.00</span> m/s</div>
    <div>Velocity: (<span id="debug-vx">0.00</span>, <span id="debug-vz">0.00</span>)</div>
    <div>Accel: (<span id="debug-ax">0.00</span>, <span id="debug-az">0.00</span>)</div>
    <div>Input: (<span id="debug-ix">0</span>, <span id="debug-iz">0</span>)</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<script>
try {
  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * PHYSICS CONFIGURATION
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const physicsConfig = {
    mass: 1.0,
    maxSpeed: 5.0,
    moveForce: 12.0,
    airResistance: 0.98,
    groundFriction: 0.9,
    bounciness: 0.4,
    wallFriction: 0.9,
  };

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ECS ARCHITECTURE
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const ComponentTypes = { 
    TRANSFORM: 'transform', VELOCITY: 'velocity', PHYSICS: 'physics', RENDER: 'render', PLAYER: 'player', 
    GOAL: 'goal', LIGHT: 'light', COLLECTIBLE: 'collectible', POWER_UP: 'powerup'
  };

  class ECSWorld {
    constructor() {
      this.entities = new Map();
      this.components = new Map();
      this.systems = [];
      this.nextEntityId = 1;
      
      Object.values(ComponentTypes).forEach(type => {
        this.components.set(type, new Map());
      });
    }
    
    createEntity() {
      const id = this.nextEntityId++;
      this.entities.set(id, new Set());
      return id;
    }
    
    addComponent(entityId, componentType, data = {}) {
      if (!this.entities.has(entityId)) return false;
      this.entities.get(entityId).add(componentType);
      this.components.get(componentType).set(entityId, data);
      return true;
    }
    
    getComponent(entityId, componentType) {
      return this.components.get(componentType).get(entityId);
    }
    
    hasComponent(entityId, componentType) {
      return this.entities.has(entityId) && this.entities.get(entityId).has(componentType);
    }
    
    removeComponent(entityId, componentType) {
        if (!this.hasComponent(entityId, componentType)) return;
        this.entities.get(entityId).delete(componentType);
        this.components.get(componentType).delete(entityId);
    }

    removeEntity(entityId) {
        if (!this.entities.has(entityId)) return;
        this.entities.get(entityId).forEach(componentType => {
            this.removeComponent(entityId, componentType);
        });
        this.entities.delete(entityId);
    }
    
    query(componentTypes) {
      const results = [];
      for (const [entityId, entityComponents] of this.entities) {
        if (componentTypes.every(type => entityComponents.has(type))) {
          results.push(entityId);
        }
      }
      return results;
    }
    
    addSystem(systemFunction) {
      this.systems.push(systemFunction);
    }
    
    update(deltaTime) {
      this.systems.forEach(system => system(this, deltaTime));
    }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * MAZE GENERATION
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  function generateSolvableMaze(cols, rows) {
    const grid = Array(rows).fill(0).map(() => Array(cols).fill(0).map(() => ({ visited: false, walls: [true, true, true, true], isPath: false, zone: null })));
    const stack = [];
    let current = {r: 0, c: 0};
    grid[0][0].visited = true;
    const directions = [[-1, 0, 0, 2], [0, 1, 1, 3], [1, 0, 2, 0], [0, -1, 3, 1]];
    do {
      const {r, c} = current;
      const neighbors = directions.filter(([dr, dc]) => {
        const nr = r + dr; const nc = c + dc;
        return nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].visited;
      });
      if (neighbors.length > 0) {
        const [dr, dc, wallIdx, oppositeIdx] = neighbors[Math.floor(Math.random() * neighbors.length)];
        const nr = current.r + dr; const nc = current.c + dc;
        grid[current.r][current.c].walls[wallIdx] = false;
        grid[nr][nc].visited = true;
        grid[nr][nc].walls[oppositeIdx] = false;
        stack.push(current);
        current = {r: nr, c: nc};
      } else {
        current = stack.pop();
      }
    } while (stack.length > 0);
    
    // Designate a central ice zone
    const zoneSize = 5;
    const zoneStartR = Math.floor(rows / 2 - zoneSize / 2);
    const zoneStartC = Math.floor(cols / 2 - zoneSize / 2);
    for (let r = zoneStartR; r < zoneStartR + zoneSize; r++) {
      for (let c = zoneStartC; c < zoneStartC + zoneSize; c++) {
        if (grid[r] && grid[r][c]) {
          grid[r][c].zone = 'ice';
        }
      }
    }
    
    return { grid, start: {r: 0, c: 0}, end: {r: rows - 1, c: cols - 1} };
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * CAMERA & MINIMAP SYSTEMS
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const CameraMode = {THIRD_PERSON:"third_person",FIRST_PERSON:"first_person"};
  class CameraSystem {
    constructor(camera) { this.camera = camera; this.mode = CameraMode.THIRD_PERSON; this.targetEntity = null; this.offset = new THREE.Vector3(0, 4, 6); this.firstPersonOffset = new THREE.Vector3(0, 0.5, 0); this.smoothness = 0.1; }
    setTarget(entityId) { this.targetEntity = entityId; }
    toggleMode() { this.mode = this.mode === CameraMode.THIRD_PERSON ? CameraMode.FIRST_PERSON : CameraMode.THIRD_PERSON; document.getElementById("camera-info").textContent = this.mode === CameraMode.THIRD_PERSON ? "Third Person" : "First Person"; }
    update(world) { if (!this.targetEntity) return; const transform = world.getComponent(this.targetEntity, ComponentTypes.TRANSFORM); if (!transform) return; const targetPos = new THREE.Vector3(transform.x, transform.y, transform.z); if (this.mode === CameraMode.THIRD_PERSON) { const cameraPos = targetPos.clone().add(this.offset); this.camera.position.lerp(cameraPos, this.smoothness); this.camera.lookAt(targetPos); } else { const firstPersonPos = targetPos.clone().add(this.firstPersonOffset); this.camera.position.lerp(firstPersonPos, this.smoothness * 2); const velocity = world.getComponent(this.targetEntity, ComponentTypes.VELOCITY); if (velocity && (Math.abs(velocity.vx) > 0.1 || Math.abs(velocity.vz) > 0.1)) { const lookDirection = new THREE.Vector3(velocity.vx, 0, velocity.vz).normalize(); this.camera.lookAt(targetPos.clone().add(lookDirection)); } else { this.camera.lookAt(targetPos.x, targetPos.y, targetPos.z - 1); } } }
  }
  
  class MinimapSystem {
    constructor(canvasId, maze, cols, rows) { this.canvas = document.getElementById(canvasId); this.ctx = this.canvas.getContext("2d"); this.maze = maze; this.cols = cols; this.rows = rows; this.cellSize = this.canvas.width / Math.max(cols, rows); this.exploredCells = new Set(); this.visible = true; this.playerEntity = null; this.goalPos = null; }
    setPlayer(entityId) { this.playerEntity = entityId; }
    setGoal(goalPos) { this.goalPos = goalPos; }
    toggle() { this.visible = !this.visible; document.getElementById("minimap-container").style.display = this.visible ? "block" : "none"; }
    markExplored(row, col, radius = 1) { for (let r = Math.max(0, row - radius); r <= Math.min(this.rows - 1, row + radius); r++) { for (let c = Math.max(0, col - radius); c <= Math.min(this.cols - 1, col + radius); c++) { this.exploredCells.add(`${r},${c}`); } } }
    update(world) { if (!this.visible || !this.playerEntity) return; const transform = world.getComponent(this.playerEntity, ComponentTypes.TRANSFORM); if (transform) { const playerRow = Math.floor((transform.z + this.rows * CELL_SIZE / 2) / CELL_SIZE); const playerCol = Math.floor((transform.x + this.cols * CELL_SIZE / 2) / CELL_SIZE); this.markExplored(playerRow, playerCol, 1); this.render(playerRow, playerCol); } }
    render(playerRow, playerCol) { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); for (let r = 0; r < this.rows; r++) { for (let c = 0; c < this.cols; c++) { const x = c * this.cellSize; const y = r * this.cellSize; const cell = this.maze.grid[r][c]; if (this.exploredCells.has(`${r},${c}`)) { this.ctx.fillStyle = cell.zone === 'ice' ? "#66aaff" : "#333"; this.ctx.fillRect(x, y, this.cellSize, this.cellSize); this.ctx.strokeStyle = cell.zone === 'ice' ? "#99ccff" : "#666"; this.ctx.lineWidth = 2; this.ctx.beginPath(); if (cell.walls[0]) { this.ctx.moveTo(x, y); this.ctx.lineTo(x + this.cellSize, y); } if (cell.walls[1]) { this.ctx.moveTo(x + this.cellSize, y); this.ctx.lineTo(x + this.cellSize, y + this.cellSize); } if (cell.walls[2]) { this.ctx.moveTo(x + this.cellSize, y + this.cellSize); this.ctx.lineTo(x, y + this.cellSize); } if (cell.walls[3]) { this.ctx.moveTo(x, y + this.cellSize); this.ctx.lineTo(x, y); } this.ctx.stroke(); } else { this.ctx.fillStyle = "#111"; this.ctx.fillRect(x, y, this.cellSize, this.cellSize); } } } if (this.goalPos && this.exploredCells.has(`${this.goalPos.r},${this.goalPos.c}`)) { const goalX = this.goalPos.c * this.cellSize + this.cellSize / 2; const goalY = this.goalPos.r * this.cellSize + this.cellSize / 2; this.ctx.fillStyle = "#00ff00"; this.ctx.beginPath(); this.ctx.arc(goalX, goalY, this.cellSize / 3, 0, Math.PI * 2); this.ctx.fill(); } if (playerRow >= 0 && playerRow < this.rows && playerCol >= 0 && playerCol < this.cols) { const playerX = playerCol * this.cellSize + this.cellSize / 2; const playerY = playerRow * this.cellSize + this.cellSize / 2; this.ctx.fillStyle = "#ffff00"; this.ctx.beginPath(); this.ctx.arc(playerX, playerY, this.cellSize / 4, 0, Math.PI * 2); this.ctx.fill(); } }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * AUDIO SYSTEM
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  class AudioSystem {
    constructor(){ this.isMusicMuted=!1; this.isSfxMuted=!1; this.sounds={ music:new Howl({src:["https://goldfirestudios.com/proj/howlerjs/sound.mp3"],loop:!0,volume:.3}), sfx:new Howl({src:["https://goldfirestudios.com/proj/howlerjs/sounds.mp3"], sprite:{collision:[893,764],goal:[2049,1152],collect:[3500,450],powerup:[0,800],ice_enter:[4500, 500]}}) }; this.musicStarted=!1 }
    startMusic(){ if(!this.musicStarted&&!this.isMusicMuted){this.sounds.music.play();this.musicStarted=!0} }
    playSound(e){ this.isSfxMuted||this.sounds.sfx.play(e) }
    toggleMusic(){ this.isMusicMuted=!this.isMusicMuted; this.sounds.music.mute(this.isMusicMuted); document.getElementById("toggle-music").classList.toggle("muted",this.isMusicMuted) }
    toggleSfx(){ this.isSfxMuted=!this.isSfxMuted; document.getElementById("toggle-sfx").classList.toggle("muted",this.isSfxMuted) }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * SCENE SETUP & GAME STATE
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.05);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFShadowMap;
  document.body.appendChild(renderer.domElement);
  
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);
  
  const textureLoader = new THREE.TextureLoader();
  let world, cameraSystem, minimapSystem, audioSystem;
  let COLS = 20, ROWS = 20, CELL_SIZE = 2;
  let maze, walls = [];
  let playerEntity, goalEntity;
  let gameCompleted = false;
  let physicsDebugEnabled = false;
  let lastCollisionTime = 0;
  let score = 0;
  let gameTime = 0;
  let levelStartTime = 0;
  let activePowerUpTimer = null;

  function initializeGame() {
    world = new ECSWorld();
    maze = generateSolvableMaze(COLS, ROWS);
    cameraSystem = new CameraSystem(camera);
    minimapSystem = new MinimapSystem('minimap', maze, COLS, ROWS);
    minimapSystem.setGoal(maze.end);
    if (!audioSystem) { audioSystem = new AudioSystem(); }
    
    // Clear scene more safely
    while(scene.children.length > 0){ 
        const child = scene.children[0];
        if(child.isMesh || child.isGroup) {
            scene.remove(child);
            if(child.geometry) child.geometry.dispose();
            if(child.material) child.material.dispose();
        } else {
            scene.remove(child);
        }
    }
    // Re-add lights after clearing
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    scene.add(directionalLight);
    
    buildMazeGeometry();
    createPlayer();
    createGoal();
    createCollectibles(10);
    createPowerUps(2);
    
    cameraSystem.setTarget(playerEntity);
    minimapSystem.setPlayer(playerEntity);
    if (world.systems.length === 0) { setupSystems(); }
    
    gameCompleted = false;
    score = 0;
    levelStartTime = performance.now();
    document.getElementById('goal-indicator').style.opacity = '0';
    document.getElementById('score').textContent = score;
  }

  function buildMazeGeometry() {
    walls = [];
    const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.8 });
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
    const iceFloorMaterial = new THREE.MeshPhongMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, reflectivity: 0.8 });
    const iceWallMaterial = new THREE.MeshStandardMaterial({ color: 0xadd8e6, roughness: 0.1, metalness: 0.1 });

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(COLS * CELL_SIZE, ROWS * CELL_SIZE), floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, 1.5, 0.2);

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cell = maze.grid[r][c];
        const x = (c - COLS / 2 + 0.5) * CELL_SIZE;
        const z = (r - ROWS / 2 + 0.5) * CELL_SIZE;

        const currentWallMaterial = cell.zone === 'ice' ? iceWallMaterial : wallMaterial;

        if (cell.walls[0]) { const wall = new THREE.Mesh(wallGeometry, currentWallMaterial); wall.position.set(x, 0.75, z - CELL_SIZE / 2); wall.castShadow = true; scene.add(wall); walls.push({ x, z: z - CELL_SIZE / 2, horizontal: true }); }
        if (cell.walls[3]) { const wall = new THREE.Mesh(wallGeometry, currentWallMaterial); wall.rotation.y = Math.PI / 2; wall.position.set(x - CELL_SIZE / 2, 0.75, z); wall.castShadow = true; scene.add(wall); walls.push({ x: x - CELL_SIZE / 2, z, horizontal: false }); }
        if (r === ROWS - 1 && cell.walls[2]) { const wall = new THREE.Mesh(wallGeometry, currentWallMaterial); wall.position.set(x, 0.75, z + CELL_SIZE / 2); wall.castShadow = true; scene.add(wall); walls.push({ x, z: z + CELL_SIZE / 2, horizontal: true }); }
        if (c === COLS - 1 && cell.walls[1]) { const wall = new THREE.Mesh(wallGeometry, currentWallMaterial); wall.rotation.y = Math.PI / 2; wall.position.set(x + CELL_SIZE / 2, 0.75, z); wall.castShadow = true; scene.add(wall); walls.push({ x: x + CELL_SIZE / 2, z, horizontal: false }); }
      }
    }

    const zoneSize = 5;
    const iceFloorGeom = new THREE.PlaneGeometry(zoneSize * CELL_SIZE, zoneSize * CELL_SIZE);
    const iceFloorMesh = new THREE.Mesh(iceFloorGeom, iceFloorMaterial);
    iceFloorMesh.rotation.x = -Math.PI / 2;
    iceFloorMesh.position.y = 0.01;
    iceFloorMesh.receiveShadow = true;
    scene.add(iceFloorMesh);
  }

  function createPlayer() {
    playerEntity = world.createEntity();
    const startX = -(COLS / 2 - 0.5) * CELL_SIZE;
    const startZ = -(ROWS / 2 - 0.5) * CELL_SIZE;
    world.addComponent(playerEntity, ComponentTypes.TRANSFORM, { x: startX, y: 0.4, z: startZ });
    world.addComponent(playerEntity, ComponentTypes.VELOCITY, { vx: 0, vz: 0 });
    world.addComponent(playerEntity, ComponentTypes.PHYSICS, { ...physicsConfig, acceleration: { x: 0, z: 0 }, isGrounded: true });
    world.addComponent(playerEntity, ComponentTypes.PLAYER, {});
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0x444400, emissiveIntensity: 0.3, roughness: 0.4, metalness: 0.1 }));
    mesh.castShadow = true;
    world.addComponent(playerEntity, ComponentTypes.RENDER, { mesh: mesh });
    const light = new THREE.PointLight(0xffff88, 1.5, 10);
    mesh.add(light);
    world.addComponent(playerEntity, ComponentTypes.LIGHT, { light: light });
    scene.add(mesh);
  }

  function createGoal() {
    goalEntity = world.createEntity();
    const goalX = (maze.end.c - COLS / 2 + 0.5) * CELL_SIZE;
    const goalZ = (maze.end.r - ROWS / 2 + 0.5) * CELL_SIZE;
    world.addComponent(goalEntity, ComponentTypes.TRANSFORM, { x: goalX, y: 0.5, z: goalZ });
    world.addComponent(goalEntity, ComponentTypes.GOAL, {});
    const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1, 8), new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x004400, emissiveIntensity: 0.5 }));
    world.addComponent(goalEntity, ComponentTypes.RENDER, { mesh: mesh });
    const light = new THREE.PointLight(0x00ff00, 2, 8);
    light.position.set(0, 1, 0);
    mesh.add(light);
    scene.add(mesh);
  }

  function createCollectibles(count) {
    const geometry = new THREE.SphereGeometry(0.15, 8, 8);
    const material = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xccab00, metalness: 0.6, roughness: 0.2 });
    for (let i = 0; i < count; i++) {
      const collectibleId = world.createEntity();
      let r, c;
      do { r = Math.floor(Math.random() * ROWS); c = Math.floor(Math.random() * COLS); } while ((r === 0 && c === 0) || (r === ROWS - 1 && c === COLS - 1) || (maze.grid[r] && maze.grid[r][c].zone === 'ice'));
      const x = (c - COLS / 2 + 0.5) * CELL_SIZE;
      const z = (r - ROWS / 2 + 0.5) * CELL_SIZE;
      world.addComponent(collectibleId, ComponentTypes.TRANSFORM, { x: x, y: 0.4, z: z });
      const mesh = new THREE.Mesh(geometry, material);
      world.addComponent(collectibleId, ComponentTypes.RENDER, { mesh: mesh });
      world.addComponent(collectibleId, ComponentTypes.COLLECTIBLE, { value: 100 });
      scene.add(mesh);
    }
  }

  function createPowerUps(count) {
    const geometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const material = new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x0066cc, metalness: 0.2, roughness: 0.1 });
    for (let i = 0; i < count; i++) {
      const powerUpId = world.createEntity();
      let r, c;
      do { r = Math.floor(Math.random() * ROWS); c = Math.floor(Math.random() * COLS); } while ((r === 0 && c === 0) || (r === ROWS - 1 && c === COLS - 1));
      const x = (c - COLS / 2 + 0.5) * CELL_SIZE;
      const z = (r - ROWS / 2 + 0.5) * CELL_SIZE;
      world.addComponent(powerUpId, ComponentTypes.TRANSFORM, { x, y: 0.4, z });
      const mesh = new THREE.Mesh(geometry, material);
      world.addComponent(powerUpId, ComponentTypes.RENDER, { mesh });
      world.addComponent(powerUpId, ComponentTypes.POWER_UP, { type: 'speed_boost', duration: 5000, multiplier: 1.5 });
      scene.add(mesh);
    }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ECS SYSTEMS
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  function setupSystems() {
    world.addSystem((world, deltaTime) => { const players = world.query([ComponentTypes.PLAYER, ComponentTypes.PHYSICS]); for (const entityId of players) { const physics = world.getComponent(entityId, ComponentTypes.PHYSICS); physics.acceleration.x = 0; physics.acceleration.z = 0; let inputX = 0, inputZ = 0; if (keyState['KeyD'] || keyState['ArrowRight']) inputX += 1; if (keyState['KeyA'] || keyState['ArrowLeft']) inputX -= 1; if (keyState['KeyS'] || keyState['ArrowDown']) inputZ += 1; if (keyState['KeyW'] || keyState['ArrowUp']) inputZ -= 1; const inputLength = Math.hypot(inputX, inputZ); if (inputLength > 0) { inputX /= inputLength; inputZ /= inputLength; const force = physics.moveForce; physics.acceleration.x += (inputX * force) / physics.mass; physics.acceleration.z += (inputZ * force) / physics.mass; } } });
    world.addSystem((world, deltaTime) => { const physicsEntities = world.query([ComponentTypes.VELOCITY, ComponentTypes.PHYSICS]); deltaTime = Math.min(deltaTime, 1 / 30); for (const entityId of physicsEntities) { const velocity = world.getComponent(entityId, ComponentTypes.VELOCITY); const physics = world.getComponent(entityId, ComponentTypes.PHYSICS); velocity.vx += physics.acceleration.x * deltaTime; velocity.vz += physics.acceleration.z * deltaTime; const frictionFactor = Math.pow(physics.airResistance, deltaTime * 10); velocity.vx *= frictionFactor; velocity.vz *= frictionFactor; if (physics.isGrounded) { const groundFrictionFactor = Math.pow(physics.groundFriction, deltaTime * 8); velocity.vx *= groundFrictionFactor; velocity.vz *= groundFrictionFactor; } const currentSpeed = Math.hypot(velocity.vx, velocity.vz); if (currentSpeed > physics.maxSpeed) { const scale = physics.maxSpeed / currentSpeed; velocity.vx *= scale; velocity.vz *= scale; } if (Math.abs(velocity.vx) < 0.02) velocity.vx = 0; if (Math.abs(velocity.vz) < 0.02) velocity.vz = 0; } });
    world.addSystem((world, deltaTime) => { const movableEntities = world.query([ComponentTypes.TRANSFORM, ComponentTypes.VELOCITY, ComponentTypes.PLAYER]); for (const entityId of movableEntities) { const transform = world.getComponent(entityId, ComponentTypes.TRANSFORM); const velocity = world.getComponent(entityId, ComponentTypes.VELOCITY); const oldX = transform.x; const oldZ = transform.z; transform.x += velocity.vx * deltaTime; if (checkCollision(transform.x, oldZ)) { transform.x = oldX; velocity.vx *= -physicsConfig.bounciness; velocity.vz *= physicsConfig.wallFriction; if (Math.abs(velocity.vx) > 1.5) audioSystem.playSound('collision'); } transform.z += velocity.vz * deltaTime; if (checkCollision(transform.x, transform.z)) { transform.z = oldZ; velocity.vz *= -physicsConfig.bounciness; velocity.vx *= physicsConfig.wallFriction; if (Math.abs(velocity.vz) > 1.5) audioSystem.playSound('collision'); } } });
    world.addSystem((world, deltaTime) => { const renderableEntities = world.query([ComponentTypes.TRANSFORM, ComponentTypes.RENDER]); for (const entityId of renderableEntities) { const transform = world.getComponent(entityId, ComponentTypes.TRANSFORM); const render = world.getComponent(entityId, ComponentTypes.RENDER); if (render.mesh) { render.mesh.position.set(transform.x, transform.y, transform.z); if (world.hasComponent(entityId, ComponentTypes.PLAYER)) { const velocity = world.getComponent(entityId, ComponentTypes.VELOCITY); render.mesh.rotation.x += velocity.vz * deltaTime * 0.5; render.mesh.rotation.z -= velocity.vx * deltaTime * 0.5; } } } });
    world.addSystem((world) => { if (gameCompleted) return; const player = world.query([ComponentTypes.PLAYER, ComponentTypes.TRANSFORM])[0]; if (!player) return; const playerTransform = world.getComponent(player, ComponentTypes.TRANSFORM); const collectibles = world.query([ComponentTypes.COLLECTIBLE, ComponentTypes.TRANSFORM, ComponentTypes.RENDER]); for (const collectibleId of collectibles) { const collectibleTransform = world.getComponent(collectibleId, ComponentTypes.TRANSFORM); const distance = Math.hypot(playerTransform.x - collectibleTransform.x, playerTransform.z - collectibleTransform.z); if (distance < 0.5) { score += world.getComponent(collectibleId, ComponentTypes.COLLECTIBLE).value; document.getElementById('score').textContent = score; audioSystem.playSound('collect'); scene.remove(world.getComponent(collectibleId, ComponentTypes.RENDER).mesh); world.removeEntity(collectibleId); } } });
    world.addSystem((world) => { if (gameCompleted) return; const player = world.query([ComponentTypes.PLAYER, ComponentTypes.TRANSFORM, ComponentTypes.PHYSICS, ComponentTypes.LIGHT])[0]; if (!player) return; const playerTransform = world.getComponent(player, ComponentTypes.TRANSFORM); const powerUps = world.query([ComponentTypes.POWER_UP, ComponentTypes.TRANSFORM, ComponentTypes.RENDER]); for (const powerUpId of powerUps) { const powerUpTransform = world.getComponent(powerUpId, ComponentTypes.TRANSFORM); const distance = Math.hypot(playerTransform.x - powerUpTransform.x, playerTransform.z - powerUpTransform.z); if (distance < 0.6) { const powerUp = world.getComponent(powerUpId, ComponentTypes.POWER_UP); const physics = world.getComponent(player, ComponentTypes.PHYSICS); const light = world.getComponent(player, ComponentTypes.LIGHT).light; audioSystem.playSound('powerup'); physics.maxSpeed *= powerUp.multiplier; physics.moveForce *= powerUp.multiplier; light.intensity *= 2; document.getElementById('powerup-status').style.opacity = '1'; if (activePowerUpTimer) clearTimeout(activePowerUpTimer); activePowerUpTimer = setTimeout(() => { physics.maxSpeed = physicsConfig.maxSpeed; physics.moveForce = physicsConfig.moveForce; light.intensity /= 2; document.getElementById('powerup-status').style.opacity = '0'; activePowerUpTimer = null; }, powerUp.duration); scene.remove(world.getComponent(powerUpId, ComponentTypes.RENDER).mesh); world.removeEntity(powerUpId); } } });
    world.addSystem((world) => { const player = world.query([ComponentTypes.PLAYER, ComponentTypes.TRANSFORM, ComponentTypes.PHYSICS])[0]; if (!player) return; const transform = world.getComponent(player, ComponentTypes.TRANSFORM); const physics = world.getComponent(player, ComponentTypes.PHYSICS); const playerRow = Math.floor((transform.z + ROWS * CELL_SIZE / 2) / CELL_SIZE); const playerCol = Math.floor((transform.x + COLS * CELL_SIZE / 2) / CELL_SIZE); if (maze.grid[playerRow] && maze.grid[playerRow][playerCol] && maze.grid[playerRow][playerCol].zone === 'ice') { if (!physics.inIceZone) { physics.inIceZone = true; audioSystem.playSound('ice_enter'); } physics.groundFriction = 0.99; physics.airResistance = 1.0; } else { physics.inIceZone = false; physics.groundFriction = physicsConfig.groundFriction; physics.airResistance = physicsConfig.airResistance; } });
    world.addSystem((world) => { if (gameCompleted) return; const players = world.query([ComponentTypes.PLAYER, ComponentTypes.TRANSFORM]); if (players.length === 0) return; const playerTransform = world.getComponent(players[0], ComponentTypes.TRANSFORM); const goals = world.query([ComponentTypes.GOAL, ComponentTypes.TRANSFORM]); if (goals.length === 0) return; const goalTransform = world.getComponent(goals[0], ComponentTypes.TRANSFORM); const distance = Math.hypot(playerTransform.x - goalTransform.x, playerTransform.z - goalTransform.z); if (distance < 1) { gameCompleted = true; const timeBonus = Math.max(0, 10000 - Math.floor(gameTime * 10)); score += timeBonus; document.getElementById('score').textContent = score; audioSystem.playSound('goal'); document.getElementById('goal-indicator').style.opacity = '1'; setTimeout(initializeGame, 3000); } });
    world.addSystem(() => { if (gameCompleted) return; gameTime = (performance.now() - levelStartTime) / 1000; const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0'); const seconds = Math.floor(gameTime % 60).toString().padStart(2, '0'); document.getElementById('timer').textContent = `${minutes}:${seconds}`; });
    world.addSystem((world) => { if (!physicsDebugEnabled) return; const player = world.query([ComponentTypes.PLAYER, ComponentTypes.VELOCITY, ComponentTypes.PHYSICS])[0]; if (!player) return; const velocity = world.getComponent(player, ComponentTypes.VELOCITY); const physics = world.getComponent(player, ComponentTypes.PHYSICS); const speed = Math.hypot(velocity.vx, velocity.vz); document.getElementById('debug-speed').textContent = speed.toFixed(2); document.getElementById('debug-vx').textContent = velocity.vx.toFixed(2); document.getElementById('debug-vz').textContent = velocity.vz.toFixed(2); document.getElementById('debug-ax').textContent = physics.acceleration.x.toFixed(2); document.getElementById('debug-az').textContent = physics.acceleration.z.toFixed(2); });
  }

  function checkCollision(x,z,radius=.3){const buffer=.1;if(x<-COLS*CELL_SIZE/2+radius||x>COLS*CELL_SIZE/2-radius||z<-ROWS*CELL_SIZE/2+radius||z>ROWS*CELL_SIZE/2-radius)return!0;for(const wall of walls){const dx=Math.abs(x-wall.x),dz=Math.abs(z-wall.z);if(wall.horizontal){if(dz<radius+buffer&&dx<CELL_SIZE/2+radius)return!0}else if(dx<radius+buffer&&dz<CELL_SIZE/2+radius)return!0}return!1}

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * INPUT HANDLING
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const keyState = {};
  window.addEventListener('keydown', (e) => {
    if (audioSystem) { audioSystem.startMusic(); }
    keyState[e.code] = true;
    if (document.activeElement === document.body) {
        if (e.code === 'KeyC') { cameraSystem.toggleMode(); }
        else if (e.code === 'KeyM') { minimapSystem.toggle(); }
        else if (e.code === 'KeyR') { initializeGame(); }
        else if (e.code === 'KeyP') {
            physicsDebugEnabled = !physicsDebugEnabled;
            document.getElementById('physics-debug').style.display = physicsDebugEnabled ? 'block' : 'none';
        }
        else if (e.code === 'KeyJ') { if (audioSystem) audioSystem.toggleMusic(); }
        else if (e.code === 'KeyK') { if (audioSystem) audioSystem.toggleSfx(); }
    }
  });
  window.addEventListener('keyup', (e) => { keyState[e.code] = false; });
  window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  document.getElementById('toggle-music').addEventListener('click', () => { if (audioSystem) audioSystem.toggleMusic(); });
  document.getElementById('toggle-sfx').addEventListener('click', () => { if (audioSystem) audioSystem.toggleSfx(); });

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * MAIN GAME LOOP
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  let lastTime = performance.now();
  function gameLoop(currentTime) {
    requestAnimationFrame(gameLoop);
    const rawDeltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    const deltaTime = Math.min(rawDeltaTime, 1/30); 
    if (world) { world.update(deltaTime); }
    if (cameraSystem) { cameraSystem.update(world); }
    if (minimapSystem) { minimapSystem.update(world); }
    renderer.render(scene, camera);
  }

  // Initialize and start the game
  initializeGame();
  gameLoop(lastTime);
  console.log("ðŸŽ® Advanced Physics-Based Maze Game Loaded! V5 with Special Zones.");

} catch (error) {
  console.error("Failed to initialize maze game:", error);
  document.body.innerHTML = `<div style="color:white;text-align:center;margin-top:50px;font-family:Arial;"><h2>Failed to initialize maze game</h2><p>Error: ${error.message}</p><p>Please check the browser console for more details.</p></div>`;
}
</script>
</body>
</html>
