<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>NEXUS MAZE - Professional Edition (ECS)</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    body { 
      margin: 0; 
      padding: 0; 
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
      font-family: 'Orbitron', monospace;
      overflow: hidden;
      cursor: none;
    }
    
    .custom-cursor {
      position: fixed;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, #00f4ff 30%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: screen;
      transition: transform 0.1s ease;
    }
    
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #00f4ff;
      z-index: 100;
      font-size: 14px;
      background: linear-gradient(135deg, rgba(0,244,255,0.1), rgba(0,100,255,0.1));
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0,244,255,0.3);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0,244,255,0.2);
      transition: all 0.3s ease;
    }
    
    #ui:hover {
      background: linear-gradient(135deg, rgba(0,244,255,0.15), rgba(0,100,255,0.15));
      box-shadow: 0 12px 40px rgba(0,244,255,0.3);
    }
    
    .ui-title {
      font-weight: 900;
      font-size: 18px;
      text-shadow: 0 0 10px #00f4ff;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #00f4ff, #0080ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .ui-stat {
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .ui-label {
      color: #80c7ff;
      text-shadow: 0 0 5px rgba(128,199,255,0.5);
    }
    
    .ui-value {
      color: #00f4ff;
      font-weight: 700;
      text-shadow: 0 0 10px #00f4ff;
      min-width: 60px;
      text-align: right;
    }
    
    #controls {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(0,244,255,0.3);
      font-size: 11px;
      color: #60a0ff;
    }
    
    .control-group {
      margin: 5px 0;
    }
    
    #minimap {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 180px;
      height: 180px;
      border: 2px solid #00f4ff;
      border-radius: 15px;
      background: linear-gradient(135deg, rgba(0,20,40,0.9), rgba(0,40,80,0.9));
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,244,255,0.3);
      overflow: hidden;
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .loading-title {
      font-size: 48px;
      font-weight: 900;
      background: linear-gradient(45deg, #00f4ff, #0080ff, #8000ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(0,244,255,0.5);
      margin-bottom: 20px;
      animation: glow 2s ease-in-out infinite alternate;
    }
    
    .loading-subtitle {
      color: #60a0ff;
      font-size: 18px;
      margin-bottom: 40px;
      text-shadow: 0 0 10px rgba(96,160,255,0.5);
    }
    
    .progress-bar {
      width: 400px;
      height: 4px;
      background: rgba(0,244,255,0.2);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 20px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #00f4ff, #0080ff);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px #00f4ff;
    }
    
    #loading-status {
      color: #80c7ff;
      font-size: 14px;
      text-align: center;
    }

    #audio-button {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, rgba(0,244,255,0.2), rgba(0,100,255,0.2));
      backdrop-filter: blur(10px);
      border: 2px solid rgba(0,244,255,0.5);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.3s ease;
      z-index: 100;
    }

    #audio-button:hover {
      background: linear-gradient(135deg, rgba(0,244,255,0.4), rgba(0,100,255,0.4));
      box-shadow: 0 0 20px rgba(0,244,255,0.6);
      transform: scale(1.1);
    }

    #audio-button.muted {
      opacity: 0.5;
    }
    
    @keyframes glow {
      from { filter: drop-shadow(0 0 20px rgba(0,244,255,0.5)); }
      to { filter: drop-shadow(0 0 40px rgba(0,244,255,0.8)); }
    }
  </style>
</head>
<body>
  <div class="custom-cursor" id="cursor"></div>
  <div id="loading">
    <div class="loading-title">NEXUS MAZE</div>
    <div class="loading-subtitle">Professional Edition</div>
    <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
    <div id="loading-status">Initializing quantum maze systems...</div>
  </div>
  <div id="ui" style="display: none;">
    <div class="ui-title">⬢ NEXUS CONTROL</div>
    <div class="ui-stat"><span class="ui-label">SCORE</span><span class="ui-value" id="score">0</span></div>
    <div class="ui-stat"><span class="ui-label">TIME</span><span class="ui-value" id="time">0s</span></div>
    <div class="ui-stat"><span class="ui-label">LEVEL</span><span class="ui-value" id="level">1</span></div>
    <div class="ui-stat"><span class="ui-label">HEALTH</span><span class="ui-value" id="health">💚 100%</span></div>
    <div class="ui-stat"><span class="ui-label">ENERGY</span><span class="ui-value" id="energy">⚡ 100%</span></div>
    <div class="ui-stat"><span class="ui-label">COORDS</span><span class="ui-value" id="position">(0, 0)</span></div>
    <div id="controls">
      <div class="control-group"><strong>MOVEMENT:</strong> WASD / Arrows</div>
      <div class="control-group"><strong>BOOST:</strong> Hold SHIFT</div>
      <div class="control-group" id="jump-status"><strong>QUANTUM JUMP:</strong> SPACE</div>
      <div class="control-group"><strong>NEW MAZE:</strong> R Key</div>
      <div class="control-group"><strong>CAMERA:</strong> C Key</div>
      <div class="control-group"><strong>SOUND:</strong> M Key</div>
    </div>
  </div>
  <canvas id="minimap" style="display: none;"></canvas>
  <button id="audio-button" style="display: none;">🔊</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  
  <script>
    class SimpleECS {
        constructor() {
            this.entities = new Set();
            this.nextEntityId = 1;
            this.componentRegistry = new Map();
            this.queryCache = new Map();
        }

        createWorld() {
            return this;
        }

        addEntity() {
            const id = this.nextEntityId++;
            this.entities.add(id);
            return id;
        }

        removeEntity(world, id) {
            if (!this.entities.has(id)) return;
            this.entities.delete(id);
            for (const cache of this.queryCache.values()) {
                cache.delete(id);
            }
            for (const component of this.componentRegistry.values()) {
                delete component.data[id];
            }
        }
        
        _updateCaches(id) {
            for (const [queryKey, cache] of this.queryCache.entries()) {
                const components = queryKey.split(',').map(name => this.componentRegistry.get(name));
                const matches = components.every(c => c.has(id));

                if (matches) {
                    cache.add(id);
                } else {
                    cache.delete(id);
                }
            }
        }

        defineComponent(schema = {}) {
            const componentData = {};
            const componentName = `c${this.componentRegistry.size}`;
            
            const component = {
                name: componentName,
                data: componentData,
                add: (id, initialValues = {}) => {
                    componentData[id] = { ...initialValues };
                    this._updateCaches(id);
                },
                has: (id) => id in componentData,
                get: (id) => componentData[id],
                remove: (id) => {
                    const existed = id in componentData;
                    if (existed) {
                        delete componentData[id];
                        this._updateCaches(id);
                    }
                }
            };
            
            this.componentRegistry.set(componentName, component);
            return component;
        }

        addComponent(world, component, id, initialValues = {}) {
            component.add(id, initialValues);
        }

        hasComponent(world, component, id) {
            return component.has(id);
        }

        removeComponent(world, component, id) {
            component.remove(id);
        }
        
        defineQuery(components) {
            const queryKey = components.map(c => c.name).sort().join(',');

            if (!this.queryCache.has(queryKey)) {
                const cache = new Set();
                for (const id of this.entities) {
                    if (components.every(c => c.has(id))) {
                        cache.add(id);
                    }
                }
                this.queryCache.set(queryKey, cache);
            }

            return (world) => {
                return this.queryCache.get(queryKey);
            };
        }

        entityExists(world, id) {
            return this.entities.has(id);
        }
    }

    class Emitter {
        constructor() {
            this.events = {};
        }
        on(event, listener) {
            if (!this.events[event]) {
                this.events[event] = [];
            }
            this.events[event].push(listener);
        }
        emit(event, payload) {
            if (this.events[event]) {
                this.events[event].forEach(listener => listener(payload));
            }
        }
    }

    class GameStateManager extends Emitter {
        constructor() {
            super();
            this.reset();
        }

        get score() { return this._score; }
        set score(value) {
            this._score = value;
            this.emit('scoreChanged', this._score);
        }

        get health() { return this._health; }
        set health(value) {
            const newHealth = Math.max(0, Math.min(100, value));
            if (this._health !== newHealth) {
                this._health = newHealth;
                this.emit('healthChanged', this._health);
            }
        }
        
        get energy() { return this._energy; }
        set energy(value) {
            const newEnergy = Math.max(0, Math.min(100, value));
             if (this._energy !== newEnergy) {
                this._energy = newEnergy;
                this.emit('energyChanged', this._energy);
            }
        }

        get level() { return this._level; }
        set level(value) {
            this._level = value;
            this.emit('levelChanged', this._level);
        }
        
        addScore(points, multiplier = 1) {
            this.score += points * multiplier;
        }

        reset() {
            this.score = 0;
            this.health = 100;
            this.energy = 100;
            this.level = 1;
        }
    }

    const ecs = new SimpleECS();
    const world = ecs.createWorld();

    class NexusMazeGame {
        constructor() {
            this.world = world;
            this.defineComponents();
            
            this.particlePool = [];
            
            this.gameState = new GameStateManager();
            
            this.actionMap = {
                'KeyW': 'MOVE_FORWARD',
                'ArrowUp': 'MOVE_FORWARD',
                'KeyS': 'MOVE_BACK',
                'ArrowDown': 'MOVE_BACK',
                'KeyA': 'MOVE_LEFT',
                'ArrowLeft': 'MOVE_LEFT',
                'KeyD': 'MOVE_RIGHT',
                'ArrowRight': 'MOVE_RIGHT',
                'Space': 'JUMP',
                'ShiftLeft': 'BOOST',
                'ShiftRight': 'BOOST'
            };
            this.activeActions = new Set();

            this.constants = {
                INITIAL_MAZE_SIZE: 31, CELL_SIZE: 2.5, WALL_HEIGHT: 3,
                JUMP_COST: 25, JUMP_COOLDOWN: 1500,
                PARTICLE_POOL_SIZE: 300,
                // MODIFIED: Tuned physics values for a weightier feel
                PLAYER_FORCE: 35.0,
                JUMP_FORCE: 25.0,
                FRICTION: 0.96, // A little less friction to allow for more coasting
                PLAYER_RADIUS: 0.5,
                // NEW: Bounciness factor for walls
                WALL_RESTITUTION: 0.4
            };
            this.colors = {
                primary: 0x00f4ff, secondary: 0x0080ff, accent: 0x8000ff,
                warning: 0xff6b00, success: 0x00ff80, wall: 0x2a4858,
                ground: 0x1a2332,
                // NEW: Color for sparks
                sparks: 0xffd700
            };

            this.state = {
                scene: null, camera: null, renderer: null,
                playerEid: -1, maze: [],
                startTime: null, lastTime: 0,
                cameraMode: 'third', gameState: 'playing',
                currentMazeSize: this.constants.INITIAL_MAZE_SIZE,
                groundMesh: null, gridHelper: null,
                jumpReady: true,
                minimapCanvas: null, minimapCtx: null,
                audioContext: null, audioReady: false,
                screenShake: 0,
                effectsQueue: [],
                audioMuted: false, audioInitialized: false,
                moveTimer: 0, ambientFilter: null
            };

            this.uiElements = {};
            this.init();
        }
        
        defineComponents() {
            this.Position = ecs.defineComponent();
            this.Velocity = ecs.defineComponent();
            this.ThreeJSObject = ecs.defineComponent();
            this.threeJSObjectMap = new Map();

            this.Player = ecs.defineComponent();
            this.Wall = ecs.defineComponent();
            this.Collectible = ecs.defineComponent();
            this.Goal = ecs.defineComponent();
            this.Particle = ecs.defineComponent();
            this.Trail = ecs.defineComponent();
            this.Animation = ecs.defineComponent();
            
            this.Enemy = ecs.defineComponent();
            this.PowerUp = ecs.defineComponent();
            this.MovingWall = ecs.defineComponent();
            this.Health = ecs.defineComponent();
            this.AI = ecs.defineComponent();
            this.Effect = ecs.defineComponent();
            this.Timer = ecs.defineComponent();

            this.EffectTimer = ecs.defineComponent();
            this.SpeedBoost = ecs.defineComponent();
            this.InvulnerabilityShield = ecs.defineComponent();
            this.ScoreMultiplierEffect = ecs.defineComponent();
        }

        async init() {
            this._setupCursor();
            this._setupAudioButton();
            await this._runLoadingSequence();
            this._cacheUIElements();
            this._initializeUI();
            this._addEventListeners();
            this._initThreeJS();
            this._initializeParticlePool();
            this._createLevel();
            this.state.startTime = Date.now();
            this._animate(0);
        }

        _setupCursor() {
            document.addEventListener('mousemove', (e) => {
                const cursor = document.getElementById('cursor');
                if(cursor) {
                    cursor.style.left = e.clientX - 10 + 'px';
                    cursor.style.top = e.clientY - 10 + 'px';
                }
            });
        }

        _setupAudioButton() {
            const audioButton = document.getElementById('audio-button');
            if (audioButton) {
                audioButton.addEventListener('click', () => {
                    this._toggleAudio();
                });
            }
        }

        async _initAudioOnUserGesture() {
            if (this.state.audioInitialized) return;
            
            try {
                await Tone.start();
                console.log('Audio context started');
                this.state.audioInitialized = true;
                this._createAudioSources();
                this._startAmbientSound();
            } catch (e) {
                console.warn("Failed to start audio:", e);
            }
        }

        _toggleAudio() {
            this.state.audioMuted = !this.state.audioMuted;
            const audioButton = document.getElementById('audio-button');
            
            if (this.state.audioMuted) {
                Tone.Master.mute = true;
                audioButton.textContent = '🔇';
                audioButton.classList.add('muted');
            } else {
                Tone.Master.mute = false;
                audioButton.textContent = '🔊';
                
                if (!this.state.audioInitialized) {
                    this._initAudioOnUserGesture();
                }
            }
        }

        _createAudioSources() {
            if (!this.state.audioInitialized) return;
            
            try {
                const reverb = new Tone.Reverb({ decay: 1.5, wet: 0.2 }).toDestination();
                const delay = new Tone.FeedbackDelay({ delayTime: "16n", feedback: 0.2, wet: 0.1 }).connect(reverb);
                this.state.moveSynth = new Tone.MonoSynth({ oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }, volume: -20 }).connect(delay);
                this.state.jumpSynth = new Tone.MonoSynth({ oscillator: { type: "square" }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }, filterEnvelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1, baseFrequency: 200, octaves: 4 }, volume: -10 }).connect(reverb);
                this.state.collectSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.5 }, volume: -12 }).connect(reverb);
                this.state.powerUpSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.4, release: 0.8 }, volume: -8 }).connect(reverb);
                this.state.levelUpSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { attack: 0.02, decay: 0.1, sustain: 0.6, release: 0.8 }, volume: -6 }).connect(reverb);
                this.state.damageSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }, volume: -8 }).connect(new Tone.Filter(800, "lowpass").connect(reverb));
                this.state.damageSubSynth = new Tone.MonoSynth({ oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }, volume: -6 }).toDestination();
                this.state.alertSynth = new Tone.MonoSynth({ oscillator: { type: "pulse", width: 0.1 }, envelope: { attack: 0.01, decay: 0.05, sustain: 0.5, release: 0.1 }, volume: -15 }).connect(delay);
                this.state.boostSynth = new Tone.Noise({ type: "white", volume: -20 }).connect(new Tone.Filter({ frequency: 2000, type: "bandpass", rolloff: -24 }).connect(reverb));
                this.state.boostEnvelope = new Tone.AmplitudeEnvelope({ attack: 0.1, decay: 0, sustain: 1, release: 0.3 }).toDestination();
                this.state.boostSynth.connect(this.state.boostEnvelope);
                this.state.uiClickSynth = new Tone.MonoSynth({ oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }, volume: -18 }).toDestination();
                this.state.ambientDrone = new Tone.Oscillator({ frequency: 55, type: "sine", volume: -30 }).toDestination();
                this.state.ambientPulse = new Tone.Oscillator({ frequency: 110, type: "triangle", volume: -35 }).toDestination();
                this.state.ambientLFO = new Tone.LFO({ frequency: "8n", min: 0.5, max: 1 });
                this.state.ambientFilter = new Tone.Filter({ frequency: 800, type: "lowpass", rolloff: -12 }).toDestination();
                this.state.ambientDrone.connect(this.state.ambientFilter);
                this.state.ambientPulse.connect(this.state.ambientFilter);
                this.state.ambientLFO.connect(this.state.ambientFilter.frequency);
                console.log("Audio sources created successfully");
            } catch (e) {
                console.error("Failed to create audio sources:", e);
            }
        }

        _startAmbientSound() {
            if (!this.state.audioInitialized) return;
            
            try {
                this.state.ambientDrone?.start();
                this.state.ambientPulse?.start();
                this.state.ambientLFO?.start();
            } catch (e) {
                console.warn("Failed to start ambient sound:", e);
            }
        }

        _playSound(soundName, options = {}) {
            if (!this.state.audioInitialized || this.state.audioMuted) return;
            
            try {
                const now = Tone.now();
                
                switch(soundName) {
                    case 'move':
                        if (this.state.moveSynth) {
                            const baseFreq = 80 + Math.random() * 40;
                            this.state.moveSynth.triggerAttackRelease(baseFreq, "32n", now);
                        }
                        break;
                    case 'jump':
                        if (this.state.jumpSynth) {
                            this.state.jumpSynth.triggerAttackRelease("C2", "8n", now);
                            this.state.jumpSynth.triggerAttackRelease("G3", "16n", now + 0.05);
                        }
                        break;
                    case 'collect':
                        if (this.state.collectSynth) {
                            const collectNotes = ["E5", "G5", "B5", "E6"];
                            collectNotes.forEach((note, i) => {
                                this.state.collectSynth.triggerAttackRelease(note, "32n", now + i * 0.05);
                            });
                        }
                        break;
                    case 'powerUp':
                        if (this.state.powerUpSynth) {
                            const chords = [["C4", "E4", "G4", "C5"], ["D4", "F#4", "A4", "D5"], ["E4", "G#4", "B4", "E5"], ["F4", "A4", "C5", "F5"]];
                            chords.forEach((chord, i) => {
                                this.state.powerUpSynth.triggerAttackRelease(chord, "8n", now + i * 0.15);
                            });
                        }
                        break;
                    case 'levelUp':
                        if (this.state.levelUpSynth) {
                            const melody = [{ note: "C5", duration: "8n", time: 0 }, { note: "C5", duration: "16n", time: 0.1 }, { note: "C5", duration: "16n", time: 0.2 }, { note: "G4", duration: "8n", time: 0.3 }, { note: "E5", duration: "8n", time: 0.5 }, { note: "G5", duration: "4n", time: 0.7 }, { note: "E5", duration: "8n", time: 1.0 }, { note: "C5", duration: "2n", time: 1.2 }];
                            melody.forEach(({ note, duration, time }) => {
                                this.state.levelUpSynth.triggerAttackRelease(note, duration, now + time);
                            });
                        }
                        break;
                    case 'damage':
                        if (this.state.damageSynth && this.state.damageSubSynth) {
                            this.state.damageSynth.triggerAttackRelease("16n", now);
                            this.state.damageSubSynth.triggerAttackRelease("C1", "8n", now);
                        }
                        break;
                    case 'enemyAlert':
                        if (this.state.alertSynth) {
                            this.state.alertSynth.triggerAttackRelease("A4", "32n", now);
                            this.state.alertSynth.triggerAttackRelease("F4", "32n", now + 0.1);
                        }
                        break;
                    case 'boost':
                        if (this.state.boostEnvelope) { this.state.boostEnvelope.triggerAttack(now); }
                        break;
                    case 'boostEnd':
                        if (this.state.boostEnvelope) { this.state.boostEnvelope.triggerRelease(now); }
                        break;
                    case 'uiClick':
                        if (this.state.uiClickSynth) { this.state.uiClickSynth.triggerAttackRelease(800, "64n", now); }
                        break;
                    // NEW: A sound for wall scrapes/sparks
                    case 'scrape':
                        if (this.state.moveSynth) {
                           this.state.moveSynth.triggerAttackRelease(400 + Math.random() * 200, "64n", now);
                        }
                        break;
                }
            } catch (e) { /* Silently handle audio errors */ }
        }

        _updateAmbientSound() {
            if (!this.state.audioInitialized || !this.state.ambientFilter) return;
            try {
                const targetFreq = this.state.gameState === 'playing' ? 800 + (this.gameState.level * 50) + (this.gameState.health < 30 ? 200 : 0) : 400;
                this.state.ambientFilter.frequency.rampTo(targetFreq, 2);
            } catch (e) { /* Silent fail */ }
        }

        _triggerScreenShake(intensity = 10) { this.state.screenShake = intensity; }

        _queueScoreEffect(points) {
            this.state.effectsQueue.push({
                type: 'score',
                value: points,
                time: Date.now()
            });
        }

        async _runLoadingSequence() {
             const updateProgress = (p, s) => {
                const pf = document.getElementById('progress');
                const st = document.getElementById('loading-status');
                if (pf) pf.style.width = p + '%';
                if (st) st.textContent = s;
            };
            const steps = [ { p: 30, t: 'Calibrating physics engine...' }, { p: 70, t: 'Initializing particle systems...' }, { p: 100, t: 'NEXUS MAZE ready!' } ];
            for (const step of steps) {
                await new Promise(r => setTimeout(r, 200));
                updateProgress(step.p, step.t);
            }
            return new Promise(resolve => {
                setTimeout(() => {
                    const ls = document.getElementById('loading');
                    ls.style.opacity = '0';
                    setTimeout(() => {
                        ls.style.display = 'none';
                        document.getElementById('ui').style.display = 'block';
                        document.getElementById('minimap').style.display = 'block';
                        document.getElementById('audio-button').style.display = 'flex';
                        resolve();
                    }, 1000);
                }, 500);
            });
        }
        
        _cacheUIElements() {
            this.uiElements = { score: document.getElementById('score'), time: document.getElementById('time'), level: document.getElementById('level'), health: document.getElementById('health'), energy: document.getElementById('energy'), position: document.getElementById('position'), jumpStatus: document.getElementById('jump-status') };
        }

        _initializeUI() {
            const { score, level, health, energy } = this.uiElements;
            const { gameState } = this;

            gameState.on('scoreChanged', (newScore) => {
                score.textContent = newScore.toLocaleString();
            });

            gameState.on('levelChanged', (newLevel) => {
                level.textContent = newLevel;
            });

            gameState.on('healthChanged', (newHealth) => {
                const healthPercent = Math.floor(newHealth);
                const healthIcon = healthPercent > 60 ? '💚' : healthPercent > 30 ? '💛' : '❤️';
                health.textContent = `${healthIcon} ${healthPercent}%`;
                health.style.color = healthPercent > 60 ? '#00ff80' : healthPercent > 30 ? '#ffff00' : '#ff4040';
            });

            gameState.on('energyChanged', (newEnergy) => {
                const energyPercent = Math.floor(newEnergy);
                const speedBonus = ecs.hasComponent(this.world, this.SpeedBoost, this.state.playerEid) ? '🚀' : '';
                energy.textContent = `⚡ ${energyPercent}% ${speedBonus}`;
            });
            
            gameState.emit('scoreChanged', gameState.score);
            gameState.emit('levelChanged', gameState.level);
            gameState.emit('healthChanged', gameState.health);
            gameState.emit('energyChanged', gameState.energy);
        }

        _addEventListeners() {
            const initAudio = async () => {
                if (!this.state.audioInitialized && !this.state.audioMuted) { await this._initAudioOnUserGesture(); }
                document.removeEventListener('keydown', initAudio);
                document.removeEventListener('click', initAudio);
                document.removeEventListener('touchstart', initAudio);
            };
            document.addEventListener('keydown', initAudio);
            document.addEventListener('click', initAudio);
            document.addEventListener('touchstart', initAudio);
            
            window.addEventListener('keydown', e => {
                if (e.code === 'KeyR') { this._createLevel(); this.gameState.score = Math.max(0, this.gameState.score - 50); this._playSound('uiClick'); } 
                else if (e.code === 'KeyC') { this.state.cameraMode = this.state.cameraMode === 'third' ? 'first' : 'third'; this._playSound('uiClick'); } 
                else if (e.code === 'KeyM') { this._toggleAudio(); }

                const action = this.actionMap[e.code];
                if (action) {
                    this.activeActions.add(action);
                }
            });
            
            window.addEventListener('keyup', e => {
                const action = this.actionMap[e.code];
                if (action) {
                    this.activeActions.delete(action);
                }
                
                if (action === 'BOOST' && !this.activeActions.has('BOOST')) {
                    this._playSound('boostEnd');
                }
            });

            window.addEventListener('resize', () => {
                if (this.state.camera && this.state.renderer) {
                    this.state.camera.aspect = window.innerWidth / window.innerHeight;
                    this.state.camera.updateProjectionMatrix();
                    this.state.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }

        _initThreeJS() {
            this.state.scene = new THREE.Scene();
            this.state.scene.background = new THREE.Color(0x0a0f1a);
            this.state.scene.fog = new THREE.FogExp2(0x0a0f1a, 0.02);
            this.state.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.state.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.state.renderer.setSize(window.innerWidth, window.innerHeight);
            this.state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.state.renderer.shadowMap.enabled = true;
            this.state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(this.state.renderer.domElement);
            this.state.scene.add(new THREE.AmbientLight(this.colors.primary, 0.3));
            const mainLight = new THREE.DirectionalLight(this.colors.primary, 1.5);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048; 
            mainLight.shadow.mapSize.height = 2048;
            this.state.scene.add(mainLight);
            this.state.minimapCanvas = document.getElementById('minimap');
            this.state.minimapCtx = this.state.minimapCanvas.getContext('2d');
            this.state.minimapCanvas.width = 180;
            this.state.minimapCanvas.height = 180;
        }

        _initializeParticlePool() {
            const geometry = new THREE.SphereGeometry(0.05, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });

            for (let i = 0; i < this.constants.PARTICLE_POOL_SIZE; i++) {
                const eid = ecs.addEntity(this.world);
                const mesh = new THREE.Mesh(geometry, material.clone());
                mesh.visible = false;
                this.state.scene.add(mesh);
                this.threeJSObjectMap.set(eid, mesh);
                
                ecs.addComponent(this.world, this.Particle, eid, { active: false, life: 0, maxLife: 60 });
                ecs.addComponent(this.world, this.Position, eid, { x: 0, y: 0, z: 0 });
                ecs.addComponent(this.world, this.Velocity, eid, { x: 0, y: 0, z: 0 });
                ecs.addComponent(this.world, this.ThreeJSObject, eid, { eid });
                
                this.particlePool.push(eid);
            }
        }

        _generateMaze(width, height) {
            const maze = Array(height).fill(null).map(() => Array(width).fill(1));
            const stack = [{ x: 1, y: 1 }];
            maze[1][1] = 0;
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];
                const directions = [{ x: 0, y: -2 }, { x: 2, y: 0 }, { x: 0, y: 2 }, { x: -2, y: 0 }];
                for (const dir of directions) {
                    const nx = current.x + dir.x; const ny = current.y + dir.y;
                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                        neighbors.push({ x: nx, y: ny, dir });
                    }
                }
                if (neighbors.length > 0) {
                    const chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[chosen.y][chosen.x] = 0;
                    maze[current.y + chosen.dir.y / 2][current.x + chosen.dir.x / 2] = 0;
                    stack.push(chosen);
                } else { stack.pop(); }
            }
            const complexityPasses = Math.floor(width * height * 0.003);
            for (let i = 0; i < complexityPasses; i++) {
                const x = 2 + Math.floor(Math.random() * (width - 4));
                const y = 2 + Math.floor(Math.random() * (height - 4));
                if (x % 2 === 0 && y % 2 === 1) maze[y][x] = 0;
                if (x % 2 === 1 && y % 2 === 0) maze[y][x] = 0;
            }
            return maze;
        }

        _createLevel() {
            const timerQuery = ecs.defineQuery([this.EffectTimer]);
            for (const eid of [...timerQuery(this.world)]) {
                ecs.removeEntity(this.world, eid);
            }
            
            const allEntities = [...ecs.entities];
            for(const eid of allEntities) {
                if (ecs.hasComponent(this.world, this.Particle, eid)) continue;
                const mesh = this.threeJSObjectMap.get(eid);
                if (mesh) this.state.scene.remove(mesh);
                ecs.removeEntity(this.world, eid);
                this.threeJSObjectMap.delete(eid);
            }

            if(this.state.groundMesh) this.state.scene.remove(this.state.groundMesh);
            if(this.state.gridHelper) this.state.scene.remove(this.state.gridHelper);

            const size = Math.min(this.constants.INITIAL_MAZE_SIZE + Math.floor(this.gameState.level / 2) * 4, 71);
            this.state.currentMazeSize = size;
            this.state.maze = this._generateMaze(size, size);
            this._createGround(size);
            this._createEntitiesFromMaze(size);
            this.state.gameState = 'playing';
            this._updateAmbientSound();
        }
        
        _createGround(size) {
            const groundSize = size * this.constants.CELL_SIZE;
            this.state.groundMesh = new THREE.Mesh( new THREE.PlaneGeometry(groundSize, groundSize), new THREE.MeshStandardMaterial({ color: this.colors.ground, roughness: 0.8 }) );
            this.state.groundMesh.rotation.x = -Math.PI / 2;
            this.state.groundMesh.receiveShadow = true;
            this.state.scene.add(this.state.groundMesh);
            this.state.gridHelper = new THREE.GridHelper(groundSize, size * 2, this.colors.primary, this.colors.primary);
            this.state.gridHelper.material.opacity = 0.1;
            this.state.gridHelper.material.transparent = true;
            this.state.scene.add(this.state.gridHelper);
        }

        _createEntitiesFromMaze(size) {
            let startX = 1, startZ = 1, endX = size - 2, endZ = size - 2;
            this.state.playerEid = this._createPlayer((startX - size / 2) * this.constants.CELL_SIZE, 1.2, (startZ - size / 2) * this.constants.CELL_SIZE);
            this._createTrail();
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (this.state.maze[y][x] === 1) { 
                        const worldX = (x - size / 2) * this.constants.CELL_SIZE;
                        const worldZ = (y - size / 2) * this.constants.CELL_SIZE;
                        this._createWall(worldX, worldZ); 
                    }
                }
            }
            this._createGoal((endX - size / 2) * this.constants.CELL_SIZE, (endZ - size / 2) * this.constants.CELL_SIZE);
            const enemyCount = Math.floor(this.gameState.level * 1.5 + 2);
            for (let i = 0; i < enemyCount; i++) {
                let x, z;
                do { x = Math.floor(Math.random() * (size - 4)) + 2; z = Math.floor(Math.random() * (size - 4)) + 2; } while (this.state.maze[z][x] !== 0 || (Math.abs(x - startX) < 3 && Math.abs(z - startZ) < 3));
                const enemyType = Math.random() < 0.7 ? 'patrol' : 'chaser';
                this._createEnemy((x - size / 2) * this.constants.CELL_SIZE, 1, (z - size / 2) * this.constants.CELL_SIZE, enemyType);
            }
            const powerUpCount = Math.floor(this.gameState.level * 0.8 + 1);
            for (let i = 0; i < powerUpCount; i++) {
                let x, z;
                do { x = Math.floor(Math.random() * (size - 2)) + 1; z = Math.floor(Math.random() * (size - 2)) + 1; } while (this.state.maze[z][x] !== 0);
                const powerUpTypes = ['speed', 'energy', 'shield', 'multiplier'];
                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                this._createPowerUp((x - size / 2) * this.constants.CELL_SIZE, 1.5, (z - size / 2) * this.constants.CELL_SIZE, powerUpType);
            }
            const collectibleCount = Math.floor(size * 1.2);
            for (let i = 0; i < collectibleCount; i++) {
                let x, z;
                do { x = Math.floor(Math.random() * (size - 2)) + 1; z = Math.floor(Math.random() * (size - 2)) + 1; } while (this.state.maze[z][x] !== 0);
                this._createCollectible((x - size / 2) * this.constants.CELL_SIZE, 1, (z - size / 2) * this.constants.CELL_SIZE, i);
            }
        }
        
        _createPlayer(x, y, z) {
            const eid = ecs.addEntity(this.world);
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(this.constants.PLAYER_RADIUS, 32, 32), new THREE.MeshStandardMaterial({ color: this.colors.primary, emissive: this.colors.primary, emissiveIntensity: 0.4, metalness: 0.8 }));
            mesh.castShadow = true;
            mesh.add(new THREE.PointLight(this.colors.primary, 2, 15));
            mesh.add(new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), new THREE.MeshBasicMaterial({ color: this.colors.primary, transparent: true, opacity: 0.1, side: THREE.DoubleSide })));
            this.state.scene.add(mesh);
            this.threeJSObjectMap.set(eid, mesh);
            ecs.addComponent(this.world, this.Player, eid);
            ecs.addComponent(this.world, this.Position, eid, { x, y, z });
            ecs.addComponent(this.world, this.Velocity, eid, { x: 0, y: 0, z: 0 });
            ecs.addComponent(this.world, this.ThreeJSObject, eid, { eid });
            return eid;
        }

        _createWall(x, z) {
            const eid = ecs.addEntity(this.world);
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(this.constants.CELL_SIZE, this.constants.WALL_HEIGHT, this.constants.CELL_SIZE), new THREE.MeshStandardMaterial({ color: this.colors.wall, roughness: 0.6 }));
            mesh.castShadow = true;
            mesh.position.set(x, this.constants.WALL_HEIGHT / 2, z);
            this.state.scene.add(mesh);
            this.threeJSObjectMap.set(eid, mesh);
            ecs.addComponent(this.world, this.Wall, eid, { halfSize: this.constants.CELL_SIZE / 2 });
            ecs.addComponent(this.world, this.Position, eid, { x, y: this.constants.WALL_HEIGHT / 2, z });
        }

        _createGoal(x, z) {
            const eid = ecs.addEntity(this.world);
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 0.3, 16), new THREE.MeshStandardMaterial({ color: this.colors.success, emissive: this.colors.success, emissiveIntensity: 0.5 }));
            const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 1.5, 8, 16, 1, true), new THREE.MeshBasicMaterial({ color: this.colors.success, transparent: true, opacity: 0.3, side: THREE.DoubleSide }));
            beam.position.y = 4;
            mesh.add(beam);
            this.state.scene.add(mesh);
            this.threeJSObjectMap.set(eid, mesh);
            ecs.addComponent(this.world, this.Goal, eid);
            ecs.addComponent(this.world, this.Position, eid, { x, y: 0.15, z });
            ecs.addComponent(this.world, this.Animation, eid, { speed: 0.02, phase: 0 });
            ecs.addComponent(this.world, this.ThreeJSObject, eid, { eid });
        }

        _createCollectible(x, y, z, phase) {
            const eid = ecs.addEntity(this.world);
            const mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.4), new THREE.MeshStandardMaterial({ color: this.colors.accent, emissive: this.colors.accent, emissiveIntensity: 0.4, metalness: 0.9 }));
            this.state.scene.add(mesh);
            this.threeJSObjectMap.set(eid, mesh);
            ecs.addComponent(this.world, this.Collectible, eid);
            ecs.addComponent(this.world, this.Position, eid, { x, y, z });
            ecs.addComponent(this.world, this.Animation, eid, { speed: 0.002, phase });
            ecs.addComponent(this.world, this.ThreeJSObject, eid, { eid });
        }
        
        _createTrail() {
            const eid = ecs.addEntity(this.world);
            const mesh = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: this.colors.primary, transparent: true, opacity: 0.6 }));
            mesh.points = [];
            this.state.scene.add(mesh);
            this.threeJSObjectMap.set(eid, mesh);
            ecs.addComponent(this.world, this.Trail, eid);
            ecs.addComponent(this.world, this.ThreeJSObject, eid, { eid });
        }
        
        _spawnParticleFromPool(x, y, z, color, life, velocity) {
            if (this.particlePool.length === 0) return;
            const eid = this.particlePool.pop();
            const particle = this.Particle.get(eid);
            particle.active = true;
            particle.life = life;
            particle.maxLife = life;
            const position = this.Position.get(eid);
            position.x = x;
            position.y = y;
            position.z = z;
            const vel = this.Velocity.get(eid);
            vel.x = velocity.x;
            vel.y = velocity.y;
            vel.z = velocity.z;
            const mesh = this.threeJSObjectMap.get(eid);
            mesh.material.color.set(color);
            mesh.material.opacity = 1;
            mesh.visible = true;
        }

        _createParticlesBurst(x, y, z, color, count) {
            for (let i = 0; i < count; i++) {
                const velocity = {
                    x: (Math.random() - 0.5) * 3,
                    y: (Math.random() - 0.5) * 3,
                    z: (Math.random() - 0.5) * 3
                };
                this._spawnParticleFromPool(x, y, z, color, 20 + Math.random() * 20, velocity);
            }
        }

        _createEnemy(x, y, z, type) {
            const eid = ecs.addEntity(this.world);
            let mesh, color;
            if (type === 'patrol') {
                color = this.colors.warning;
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 }));
            } else {
                color = 0xff0066;
                mesh = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.2, 6), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.4 }));
            }
            mesh.castShadow = true;
            this.state.scene.add(mesh);
            this.threeJSObjectMap.set(eid, mesh);
            ecs.addComponent(this.world, this.Enemy, eid, { type, speed: type === 'chaser' ? 2 : 1.5 });
            ecs.addComponent(this.world, this.Position, eid, { x, y, z });
            ecs.addComponent(this.world, this.Velocity, eid, { x: 0, y: 0, z: 0 });
            ecs.addComponent(this.world, this.AI, eid, { target: { x, y, z }, lastDirection: Math.random() * Math.PI * 2, timer: 0 });
            ecs.addComponent(this.world, this.Animation, eid, { speed: 0.05, phase: Math.random() * Math.PI * 2 });
            ecs.addComponent(this.world, this.ThreeJSObject, eid, { eid });
        }

        _createPowerUp(x, y, z, type) {
            const eid = ecs.addEntity(this.world);
            const colors = { speed: 0x00ffff, energy: 0xffff00, shield: 0x00ff00, multiplier: 0xff00ff };
            const mesh = new THREE.Mesh(new THREE.TetrahedronGeometry(0.6), new THREE.MeshStandardMaterial({ color: colors[type], emissive: colors[type], emissiveIntensity: 0.5, transparent: true, opacity: 0.8 }));
            this.state.scene.add(mesh);
            this.threeJSObjectMap.set(eid, mesh);
            ecs.addComponent(this.world, this.PowerUp, eid, { type });
            ecs.addComponent(this.world, this.Position, eid, { x, y, z });
            ecs.addComponent(this.world, this.Animation, eid, { speed: 0.01, phase: Math.random() * Math.PI * 2 });
            ecs.addComponent(this.world, this.ThreeJSObject, eid, { eid });
        }

        _inputSystem(deltaTime) {
            if (!ecs.entityExists(this.world, this.state.playerEid)) return;
            const eid = this.state.playerEid;
            const position = this.Position.get(eid);
            const velocity = this.Velocity.get(eid);
            
            const { PLAYER_FORCE, JUMP_FORCE } = this.constants;
            const speedBonus = ecs.hasComponent(this.world, this.SpeedBoost, this.state.playerEid) ? 1.5 : 1;
            const boostMultiplier = this.activeActions.has('BOOST') && this.gameState.energy > 0 ? 2.5 : 1;
            const finalMultiplier = boostMultiplier * speedBonus;
            
            let forceApplied = false;

            if (this.activeActions.has('MOVE_FORWARD')) { velocity.z -= PLAYER_FORCE * finalMultiplier * deltaTime; forceApplied = true; }
            if (this.activeActions.has('MOVE_BACK')) { velocity.z += PLAYER_FORCE * finalMultiplier * deltaTime; forceApplied = true; }
            if (this.activeActions.has('MOVE_LEFT')) { velocity.x -= PLAYER_FORCE * finalMultiplier * deltaTime; forceApplied = true; }
            if (this.activeActions.has('MOVE_RIGHT')) { velocity.x += PLAYER_FORCE * finalMultiplier * deltaTime; forceApplied = true; }
            
            if (forceApplied) {
                this.state.moveTimer++;
                if (this.state.moveTimer % 12 === 0) {
                    this._playSound('move');
                }
                if (boostMultiplier > 1) {
                    this.gameState.energy -= 0.5;
                    if (!this.state.isBoosting) { this._playSound('boost'); this.state.isBoosting = true; }
                } else {
                    this.gameState.energy += 0.2;
                    if (this.state.isBoosting) { this.state.isBoosting = false; }
                }
            } else {
                if (this.state.isBoosting) { this.state.isBoosting = false; }
            }

            if (this.activeActions.has('JUMP') && this.gameState.energy >= this.constants.JUMP_COST && this.state.jumpReady) {
                this.state.jumpReady = false;
                setTimeout(() => { this.state.jumpReady = true; }, this.constants.JUMP_COOLDOWN);
                this.gameState.energy -= this.constants.JUMP_COST;
                this._playSound('jump');
                this._triggerScreenShake(5);
                
                let jumpDirection = new THREE.Vector3(velocity.x, 0, velocity.z);
                if (jumpDirection.lengthSq() < 0.001) jumpDirection.set(0, 0, -1);
                jumpDirection.normalize();

                velocity.x += jumpDirection.x * JUMP_FORCE;
                velocity.z += jumpDirection.z * JUMP_FORCE;
                
                this._createParticlesBurst(position.x, position.y, position.z, this.colors.primary, 8);
            }
        }
        
        _movementSystem(deltaTime) {
            const movingQuery = ecs.defineQuery([this.Position, this.Velocity]);
            const entities = movingQuery(this.world);
            
            const friction = Math.pow(this.constants.FRICTION, deltaTime * 60);

            for (const eid of entities) {
                const position = this.Position.get(eid);
                const velocity = this.Velocity.get(eid);
                
                if (!ecs.hasComponent(this.world, this.Particle, eid)) {
                    velocity.x *= friction;
                    velocity.z *= friction;
                }
                
                position.x += velocity.x * deltaTime;
                position.y += velocity.y * deltaTime;
                position.z += velocity.z * deltaTime;
            }
        }
        
        // MODIFIED: Entirely new collision response logic
        _collisionSystem(deltaTime) {
            const playerQuery = ecs.defineQuery([this.Player, this.Position, this.Velocity]);
            const collectibleQuery = ecs.defineQuery([this.Collectible, this.Position]);
            const goalQuery = ecs.defineQuery([this.Goal, this.Position]);
            const enemyQuery = ecs.defineQuery([this.Enemy, this.Position]);
            const powerUpQuery = ecs.defineQuery([this.PowerUp, this.Position]);
            
            const players = playerQuery(this.world);
            if(players.size === 0) return;
            const p_eid = players.values().next().value;
            const playerPos = this.Position.get(p_eid);
            const playerVel = this.Velocity.get(p_eid);

            const { CELL_SIZE, PLAYER_RADIUS, WALL_RESTITUTION } = this.constants;
            const size = this.state.currentMazeSize;
            const halfSize = size / 2;
            const w_half = CELL_SIZE / 2;

            const gridX = Math.floor((playerPos.x / CELL_SIZE) + halfSize);
            const gridZ = Math.floor((playerPos.z / CELL_SIZE) + halfSize);
            
            for (let z = gridZ - 1; z <= gridZ + 1; z++) {
                for (let x = gridX - 1; x <= gridX + 1; x++) {
                    if (this.state.maze[z] && this.state.maze[z][x] === 1) {
                        const wallWorldX = (x - halfSize) * CELL_SIZE;
                        const wallWorldZ = (z - halfSize) * CELL_SIZE;
                        
                        // AABB collision check
                        const closestX = Math.max(wallWorldX - w_half, Math.min(playerPos.x, wallWorldX + w_half));
                        const closestZ = Math.max(wallWorldZ - w_half, Math.min(playerPos.z, wallWorldZ + w_half));
                        
                        const dist_x = playerPos.x - closestX;
                        const dist_z = playerPos.z - closestZ;
                        const distanceSq = (dist_x * dist_x) + (dist_z * dist_z);

                        if (distanceSq < (PLAYER_RADIUS * PLAYER_RADIUS)) {
                            // Collision detected, find the normal
                            const normal = new THREE.Vector2(dist_x, dist_z).normalize();
                            
                            // Move player out of the wall to prevent sticking
                            const penetrationDepth = PLAYER_RADIUS - Math.sqrt(distanceSq);
                            playerPos.x += normal.x * penetrationDepth;
                            playerPos.z += normal.y * penetrationDepth;

                            // Calculate the velocity component along the normal
                            const dot = playerVel.x * normal.x + playerVel.z * normal.y;
                            
                            // Calculate the impulse for bouncing (restitution)
                            const impulseX = (1 + WALL_RESTITUTION) * dot * normal.x;
                            const impulseZ = (1 + WALL_RESTITUTION) * dot * normal.y;
                            
                            // Apply the bounce
                            playerVel.x -= impulseX;
                            playerVel.z -= impulseZ;

                            // If skidding, create sparks
                            const speed = Math.hypot(playerVel.x, playerVel.z);
                            if (speed > 2.0) {
                                this._createParticlesBurst(closestX, playerPos.y, closestZ, this.colors.sparks, 1);
                                if(Math.random() > 0.8) this._playSound('scrape');
                            }
                        }
                    }
                }
            }
            
            // --- Other collision checks remain the same ---
            for (const c_eid of [...collectibleQuery(this.world)]) {
                const collectiblePos = this.Position.get(c_eid);
                const dist = Math.hypot(playerPos.x - collectiblePos.x, playerPos.z - collectiblePos.z);
                if(dist < 1.0) {
                    const multiplierComp = ecs.hasComponent(this.world, this.ScoreMultiplierEffect, p_eid) ? this.ScoreMultiplierEffect.get(p_eid).value : 1;
                    const scoreToAdd = 25 * this.gameState.level;
                    this.gameState.addScore(scoreToAdd, multiplierComp);
                    this._queueScoreEffect(scoreToAdd * multiplierComp);

                    this.gameState.energy += 10;
                    this._playSound('collect');
                    this._createParticlesBurst(collectiblePos.x, collectiblePos.y, collectiblePos.z, this.colors.accent, 5);
                    const mesh = this.threeJSObjectMap.get(c_eid);
                    if (mesh) this.state.scene.remove(mesh);
                    this.threeJSObjectMap.delete(c_eid);
                    ecs.removeEntity(this.world, c_eid);
                }
            }
            
            for (const pu_eid of [...powerUpQuery(this.world)]) {
                const powerUpPos = this.Position.get(pu_eid);
                const powerUpData = this.PowerUp.get(pu_eid);
                const dist = Math.hypot(playerPos.x - powerUpPos.x, playerPos.z - powerUpPos.z);
                if(dist < 1.2) {
                    const timer_eid = ecs.addEntity(this.world);
                    let duration = 10000;
                    let effectComponent = null;
                    
                    switch(powerUpData.type) {
                        case 'speed':
                            effectComponent = this.SpeedBoost;
                            ecs.addComponent(this.world, effectComponent, p_eid);
                            break;
                        case 'shield':
                            duration = 8000;
                            effectComponent = this.InvulnerabilityShield;
                            ecs.addComponent(this.world, effectComponent, p_eid);
                            break;
                        case 'multiplier':
                            duration = 15000;
                            effectComponent = this.ScoreMultiplierEffect;
                            ecs.addComponent(this.world, effectComponent, p_eid, { value: 3 });
                            break;
                        case 'energy':
                            this.gameState.energy = 100;
                            break;
                    }

                    if (effectComponent) {
                         ecs.addComponent(this.world, this.EffectTimer, timer_eid, { target: p_eid, component: effectComponent, expiration: Date.now() + duration });
                    } else {
                        ecs.removeEntity(this.world, timer_eid);
                    }

                    this._playSound('powerUp');
                    this._triggerScreenShake(8);
                    this._createParticlesBurst(powerUpPos.x, powerUpPos.y, powerUpPos.z, 0xffffff, 12);
                    const mesh = this.threeJSObjectMap.get(pu_eid);
                    if (mesh) this.state.scene.remove(mesh);
                    this.threeJSObjectMap.delete(pu_eid);
                    ecs.removeEntity(this.world, pu_eid);
                }
            }
            
            if (!ecs.hasComponent(this.world, this.InvulnerabilityShield, p_eid)) {
                const enemies = enemyQuery(this.world);
                for (const e_eid of enemies) {
                    const enemyPos = this.Position.get(e_eid);
                    const dist = Math.hypot(playerPos.x - enemyPos.x, playerPos.z - enemyPos.z);
                    if(dist < 1.0) {
                        this.gameState.health -= 20;
                        this._playSound('damage');
                        this._triggerScreenShake(15);
                        this._createParticlesBurst(playerPos.x, playerPos.y, playerPos.z, 0xff0000, 8);
                        if (this.gameState.health <= 0) { this.state.gameState = 'gameOver'; }
                        
                        ecs.addComponent(this.world, this.InvulnerabilityShield, p_eid);
                        const timer_eid = ecs.addEntity(this.world);
                        ecs.addComponent(this.world, this.EffectTimer, timer_eid, { target: p_eid, component: this.InvulnerabilityShield, expiration: Date.now() + 2000 });
                    }
                }
            }
            
            const goals = goalQuery(this.world);
            if(goals.size > 0 && this.state.gameState === 'playing') {
                const g_eid = goals.values().next().value;
                const goalPos = this.Position.get(g_eid);
                const dist = Math.hypot(playerPos.x - goalPos.x, playerPos.z - goalPos.z);
                if(dist < 2.0) {
                    this.state.gameState = 'transitioning';
                    
                    const multiplierComp = ecs.hasComponent(this.world, this.ScoreMultiplierEffect, p_eid) ? this.ScoreMultiplierEffect.get(p_eid).value : 1;
                    const scoreToAdd = 200 * this.gameState.level;
                    this.gameState.addScore(scoreToAdd, multiplierComp);
                    this._queueScoreEffect(scoreToAdd * multiplierComp);

                    this.gameState.level++;
                    this.gameState.health += 25;
                    
                    this._playSound('levelUp');
                    this._triggerScreenShake(12);
                    setTimeout(() => this._createLevel(), 2000);
                }
            }
        }

        _effectsSystem() {
            const timerQuery = ecs.defineQuery([this.EffectTimer]);
            const timers = timerQuery(this.world);
            const now = Date.now();

            for (const eid of [...timers]) {
                const timer = this.EffectTimer.get(eid);
                if (now > timer.expiration) {
                    if (ecs.entityExists(this.world, timer.target)) {
                       ecs.removeComponent(this.world, timer.component, timer.target);
                    }
                    ecs.removeEntity(this.world, eid);
                }
            }
        }

        _particleSystem() {
            const particleQuery = ecs.defineQuery([this.Particle]);
            const entities = particleQuery(this.world);
            
            for(const eid of entities) {
                const particle = this.Particle.get(eid);
                
                if (!particle.active) continue;

                particle.life--;
                
                if(particle.life <= 0) {
                    particle.active = false;
                    const mesh = this.threeJSObjectMap.get(eid);
                    if (mesh) mesh.visible = false;
                    this.particlePool.push(eid);
                    continue;
                }
                
                const velocity = this.Velocity.get(eid);
                if (velocity) {
                    velocity.y -= 0.008; // Stronger gravity for particles
                }
                
                const mesh = this.threeJSObjectMap.get(eid);
                if (mesh) {
                    mesh.material.opacity = particle.life / particle.maxLife;
                }
            }
        }

        _aiSystem(deltaTime) {
            if (!ecs.entityExists(this.world, this.state.playerEid)) return;
            const enemyQuery = ecs.defineQuery([this.Enemy, this.Position, this.Velocity, this.AI]);
            const enemies = enemyQuery(this.world);
            const playerPos = this.Position.get(this.state.playerEid);
            for (const eid of enemies) {
                const enemy = this.Enemy.get(eid);
                const position = this.Position.get(eid);
                const velocity = this.Velocity.get(eid);
                const ai = this.AI.get(eid);
                ai.timer++;
                const distToPlayer = Math.hypot(playerPos.x - position.x, playerPos.z - position.z);
                if (distToPlayer < 5 && ai.timer % 60 === 0 && enemy.type === 'chaser') { this._playSound('enemyAlert'); }
                if (enemy.type === 'patrol') {
                    if (ai.timer % 120 === 0) { ai.lastDirection = Math.random() * Math.PI * 2; }
                    velocity.x = Math.cos(ai.lastDirection) * enemy.speed;
                    velocity.z = Math.sin(ai.lastDirection) * enemy.speed;
                } else if (enemy.type === 'chaser') {
                    const dx = playerPos.x - position.x;
                    const dz = playerPos.z - position.z;
                    const distance = Math.hypot(dx, dz);
                    if (distance > 0.1) {
                        const chaseSpeed = enemy.speed * (1 + Math.sin(ai.timer * 0.1) * 0.2);
                        velocity.x = (dx / distance) * chaseSpeed;
                        velocity.z = (dz / distance) * chaseSpeed;
                    }
                }
                const nextX = position.x + velocity.x * 15 * deltaTime;
                const nextZ = position.z + velocity.z * 15 * deltaTime;
                const size = this.state.currentMazeSize;
                const cellSize = this.constants.CELL_SIZE;
                const mazeX = Math.floor((nextX / cellSize) + size / 2);
                const mazeZ = Math.floor((nextZ / cellSize) + size / 2);
                if (mazeX < 0 || mazeX >= size || mazeZ < 0 || mazeZ >= size || (this.state.maze[mazeZ] && this.state.maze[mazeZ][mazeX] === 1)) {
                    if (enemy.type === 'patrol') { ai.lastDirection += (Math.PI / 2) + (Math.random() - 0.5) * Math.PI / 4; } 
                    else { const perpendicular = ai.lastDirection + Math.PI / 2; velocity.x = Math.cos(perpendicular) * enemy.speed; velocity.z = Math.sin(perpendicular) * enemy.speed; ai.lastDirection = perpendicular; }
                }
            }
        }
        
        _trailSystem() {
            const trailQuery = ecs.defineQuery([this.Trail, this.ThreeJSObject]);
            const entities = trailQuery(this.world);
            if (!ecs.entityExists(this.world, this.state.playerEid)) return;
            const playerPos = this.Position.get(this.state.playerEid);
            for(const eid of entities) {
                const trailObj = this.threeJSObjectMap.get(eid);
                trailObj.points.push(new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z));
                while(trailObj.points.length > 60) trailObj.points.shift();
                if(trailObj.points.length > 1) trailObj.geometry.setFromPoints(trailObj.points);
            }
        }
        
        _animationSystem() {
            const animatedQuery = ecs.defineQuery([this.Position, this.Animation, this.ThreeJSObject]);
            const entities = animatedQuery(this.world);
            const now = Date.now();
            for(const eid of entities) {
                const position = this.Position.get(eid);
                const animation = this.Animation.get(eid);
                const mesh = this.threeJSObjectMap.get(eid);
                if(ecs.hasComponent(this.world, this.Collectible, eid)) {
                    mesh.rotation.y += 0.03;
                    position.y = 1 + Math.sin(now * animation.speed + animation.phase) * 0.3;
                }
                if(ecs.hasComponent(this.world, this.Goal, eid)) {
                    mesh.children[0].rotation.y += animation.speed;
                    mesh.children[0].material.opacity = 0.3 + Math.sin(now * 0.003) * 0.2;
                }
                if(ecs.hasComponent(this.world, this.Enemy, eid)) {
                    mesh.rotation.y += animation.speed;
                    const bobOffset = Math.sin(now * animation.speed * 2 + animation.phase) * 0.1;
                    position.y = 1 + bobOffset;
                }
                if(ecs.hasComponent(this.world, this.PowerUp, eid)) {
                    mesh.rotation.x += animation.speed;
                    mesh.rotation.y += animation.speed * 0.7;
                    mesh.rotation.z += animation.speed * 0.3;
                    position.y = 1.5 + Math.sin(now * animation.speed + animation.phase) * 0.4;
                }
            }
        }

        // MODIFIED: Added realistic rolling simulation
        _renderSystem(deltaTime) {
            const renderQuery = ecs.defineQuery([this.Position, this.ThreeJSObject]);
            const entities = renderQuery(this.world);
            for(const eid of entities) {
                const position = this.Position.get(eid);
                const mesh = this.threeJSObjectMap.get(eid);
                if(mesh && !ecs.hasComponent(this.world, this.Trail, eid)) {
                    mesh.position.set(position.x, position.y, position.z);
                    if(ecs.hasComponent(this.world, this.Player, eid)) {
                        const velocity = this.Velocity.get(eid);
                        // This simulates the sphere's rolling based on its velocity
                        const rotationAxis = new THREE.Vector3(velocity.z, 0, -velocity.x).normalize();
                        const angularSpeed = Math.hypot(velocity.x, velocity.z) / this.constants.PLAYER_RADIUS;
                        const quaternion = new THREE.Quaternion();
                        quaternion.setFromAxisAngle(rotationAxis, angularSpeed * deltaTime);
                        mesh.quaternion.premultiply(quaternion);
                    }
                }
            }
        }
        
        _cameraSystem() {
            if (!ecs.entityExists(this.world, this.state.playerEid)) return;
            const playerPos = this.Position.get(this.state.playerEid);
            const targetPosition = new THREE.Vector3();
            const lookAtPosition = new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z);
            if (this.state.cameraMode === 'third') {
                const heightOffset = Math.max(12, this.state.currentMazeSize * 0.4);
                const distanceOffset = Math.max(10, this.state.currentMazeSize * 0.3);
                targetPosition.set(lookAtPosition.x, lookAtPosition.y + heightOffset, lookAtPosition.z + distanceOffset);
            } else {
                const heightOffset = Math.max(30, this.state.currentMazeSize * 0.8);
                targetPosition.set(lookAtPosition.x, lookAtPosition.y + heightOffset, lookAtPosition.z);
            }
            if (this.state.screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * this.state.screenShake * 0.1;
                const shakeY = (Math.random() - 0.5) * this.state.screenShake * 0.1;
                const shakeZ = (Math.random() - 0.5) * this.state.screenShake * 0.1;
                targetPosition.x += shakeX;
                targetPosition.y += shakeY;
                targetPosition.z += shakeZ;
                this.state.screenShake *= 0.9;
                if (this.state.screenShake < 0.1) this.state.screenShake = 0;
            }
            this.state.camera.position.lerp(targetPosition, 0.05);
            this.state.camera.lookAt(lookAtPosition);
        }

        _uiSystem() {
            if (this.uiElements.score && ecs.entityExists(this.world, this.state.playerEid)) {
                const playerPos = this.Position.get(this.state.playerEid);
                this.uiElements.time.textContent = Math.floor((Date.now() - this.state.startTime) / 1000) + 's';
                this.uiElements.position.textContent = `(${playerPos.x.toFixed(1)}, ${playerPos.z.toFixed(1)})`;
                const jumpColor = this.state.jumpReady ? '#00f4ff' : '#ff6b00';
                this.uiElements.jumpStatus.innerHTML = `<strong>JUMP:</strong> <span style="color: ${jumpColor};">${this.state.jumpReady ? 'READY' : 'RECHARGING'}</span>`;
                
                let powerUpText = '';
                if(ecs.hasComponent(this.world, this.InvulnerabilityShield, this.state.playerEid)) powerUpText += '🛡️ SHIELD ';
                if(ecs.hasComponent(this.world, this.ScoreMultiplierEffect, this.state.playerEid)) powerUpText += '✨ MULTIPLIER ';
                if(ecs.hasComponent(this.world, this.SpeedBoost, this.state.playerEid)) powerUpText += '🚀 SPEED ';

                if (powerUpText) { 
                    this.uiElements.jumpStatus.innerHTML += `<br><span style="color: #ff00ff; font-size: 10px;">${powerUpText}</span>`; 
                }
            }
        }
        
        _minimapSystem() {
            if (!this.state.minimapCtx || !ecs.entityExists(this.world, this.state.playerEid)) return;
            const ctx = this.state.minimapCtx;
            const canvas = this.state.minimapCanvas;
            const size = this.state.currentMazeSize;
            const scale = Math.min(canvas.width, canvas.height) / size;
            ctx.fillStyle = '#0a1a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const pixelX = x * scale; const pixelY = y * scale;
                    if (this.state.maze[y][x] === 1) { ctx.fillStyle = '#2a4858'; ctx.fillRect(pixelX, pixelY, scale, scale); } 
                    else { ctx.fillStyle = '#1a2332'; ctx.fillRect(pixelX, pixelY, scale, scale); }
                }
            }
            const collectibleQuery = ecs.defineQuery([this.Collectible, this.Position]);
            const collectibles = collectibleQuery(this.world);
            ctx.fillStyle = '#8000ff';
            for (const c_eid of collectibles) {
                const pos = this.Position.get(c_eid);
                const mazeX = Math.floor((pos.x / this.constants.CELL_SIZE) + size / 2);
                const mazeY = Math.floor((pos.z / this.constants.CELL_SIZE) + size / 2);
                ctx.fillRect(mazeX * scale + scale * 0.25, mazeY * scale + scale * 0.25, scale * 0.5, scale * 0.5);
            }
            const powerUpQuery = ecs.defineQuery([this.PowerUp, this.Position]);
            const powerUps = powerUpQuery(this.world);
            ctx.fillStyle = '#ffff00';
            for (const pu_eid of powerUps) {
                const pos = this.Position.get(pu_eid);
                const mazeX = Math.floor((pos.x / this.constants.CELL_SIZE) + size / 2);
                const mazeY = Math.floor((pos.z / this.constants.CELL_SIZE) + size / 2);
                ctx.fillRect(mazeX * scale + scale * 0.2, mazeY * scale + scale * 0.2, scale * 0.6, scale * 0.6);
            }
            const enemyQuery = ecs.defineQuery([this.Enemy, this.Position]);
            const enemies = enemyQuery(this.world);
            ctx.fillStyle = '#ff4444';
            for (const e_eid of enemies) {
                const pos = this.Position.get(e_eid);
                const mazeX = Math.floor((pos.x / this.constants.CELL_SIZE) + size / 2);
                const mazeY = Math.floor((pos.z / this.constants.CELL_SIZE) + size / 2);
                ctx.beginPath();
                ctx.arc(mazeX * scale + scale * 0.5, mazeY * scale + scale * 0.5, scale * 0.25, 0, Math.PI * 2);
                ctx.fill();
            }
            const goalQuery = ecs.defineQuery([this.Goal, this.Position]);
            const goals = goalQuery(this.world);
            if (goals.size > 0) {
                ctx.fillStyle = '#00ff80';
                const pos = this.Position.get(goals.values().next().value);
                const mazeX = Math.floor((pos.x / this.constants.CELL_SIZE) + size / 2);
                const mazeY = Math.floor((pos.z / this.constants.CELL_SIZE) + size / 2);
                ctx.fillRect(mazeX * scale + scale * 0.1, mazeY * scale + scale * 0.1, scale * 0.8, scale * 0.8);
            }
            const playerPos = this.Position.get(this.state.playerEid);
            const playerMazeX = Math.floor((playerPos.x / this.constants.CELL_SIZE) + size / 2);
            const playerMazeY = Math.floor((playerPos.z / this.constants.CELL_SIZE) + size / 2);
            const playerColor = ecs.hasComponent(this.world, this.InvulnerabilityShield, this.state.playerEid) ? '#00ff00' : '#00f4ff';
            ctx.fillStyle = playerColor;
            ctx.beginPath();
            ctx.arc(playerMazeX * scale + scale * 0.5, playerMazeY * scale + scale * 0.5, scale * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowColor = playerColor;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(playerMazeX * scale + scale * 0.5, playerMazeY * scale + scale * 0.5, scale * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        _animate(currentTime) {
            if (this.state.lastTime === 0) this.state.lastTime = currentTime;
            const deltaTime = (currentTime - this.state.lastTime) / 1000.0;
            this.state.lastTime = currentTime;

            if(this.state.gameState === 'playing') {
                this._inputSystem(deltaTime);
                this._movementSystem(deltaTime);
                this._collisionSystem(deltaTime);
                this._aiSystem(deltaTime);
                this._effectsSystem();
            }
            this._particleSystem();
            this._trailSystem();
            this._animationSystem();
            this._cameraSystem();
            this._renderSystem(deltaTime);
            this._uiSystem(); 
            this._minimapSystem();
            this.state.renderer.render(this.state.scene, this.state.camera);
            requestAnimationFrame(this._animate.bind(this));
        }
    }
    
    window.addEventListener('load', () => {
        if (typeof THREE !== 'undefined' && typeof Tone !== 'undefined') {
            new NexusMazeGame();
        } else {
            console.error('Three.js or Tone.js failed to load');
        }
    });
  </script>
</body>
</html>