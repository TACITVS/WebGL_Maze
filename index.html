<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Procedural Maze Â· ECS Â· Audio</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:Arial,sans-serif;}
    canvas{display:block}
    
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 100;
    }
    
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      pointer-events: auto;
      font-size: 14px;
      max-width: 250px;
    }
    
    #minimap-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      border: 3px solid #444;
      border-radius: 8px;
      background: rgba(0,0,0,0.9);
      pointer-events: auto;
    }
    
    #minimap {
      display: block;
      border-radius: 5px;
    }
    
    #camera-info {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #fff;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
    }
    
    #goal-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff00;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    #physics-debug {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #fff;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      display: none;
    }
    .control-key {
      background: rgba(255,255,255,0.2);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      cursor: pointer;
      display: inline-block;
      min-width: 12px;
      text-align: center;
    }
    .muted {
        text-decoration: line-through;
        opacity: 0.5;
    }
  </style>
</head>
<body>
<div id="ui">
  <div id="controls">
    <div><strong>ðŸŽ® Controls</strong></div>
    <div><span class="control-key">WASD</span> / <span class="control-key">Arrows</span> - Move</div>
    <div><span class="control-key">C</span> - Switch Camera</div>
    <div><span class="control-key">M</span> - Toggle Minimap</div>
    <div><span class="control-key">R</span> - New Maze</div>
    <div><span class="control-key">P</span> - Physics Debug</div>
    
    <div style="margin-top:10px;"><strong>ðŸ”Š Audio</strong></div>
    <div><span class="control-key" id="toggle-music">J</span> - Music</div>
    <div><span class="control-key" id="toggle-sfx">K</span> - SFX</div>

    <div style="margin-top:10px;"><strong>ðŸŽ¯ Goal:</strong> Find the green exit!</div>
    <div style="margin-top:5px;font-size:11px;opacity:0.8;">
      <em>Physics: Momentum, inertia & friction enabled!</em>
    </div>
  </div>
  
  <div id="camera-info">Third Person</div>
  
  <div id="minimap-container">
    <canvas id="minimap" width="200" height="200"></canvas>
  </div>
  
  <div id="goal-indicator">ðŸŽ‰ MAZE COMPLETED! ðŸŽ‰</div>
  
  <div id="physics-debug">
    <div><strong>Physics Debug</strong></div>
    <div>Speed: <span id="debug-speed">0.00</span> m/s</div>
    <div>Velocity: (<span id="debug-vx">0.00</span>, <span id="debug-vz">0.00</span>)</div>
    <div>Accel: (<span id="debug-ax">0.00</span>, <span id="debug-az">0.00</span>)</div>
    <div>Input: (<span id="debug-ix">0</span>, <span id="debug-iz">0</span>)</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<script>
try {
  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ECS ARCHITECTURE
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const ComponentTypes = { TRANSFORM: 'transform', VELOCITY: 'velocity', PHYSICS: 'physics', RENDER: 'render', PLAYER: 'player', CAMERA_TARGET: 'camera_target', GOAL: 'goal', LIGHT: 'light' };
  class ECSWorld {
    constructor(){this.entities=new Map();this.components=new Map();this.systems=[];this.nextEntityId=1;Object.values(ComponentTypes).forEach(t=>{this.components.set(t,new Map())})}
    createEntity(){const t=this.nextEntityId++;this.entities.set(t,new Set());return t}
    addComponent(t,s,i={}){return!!this.entities.has(t)&&(this.entities.get(t).add(s),this.components.get(s).set(t,i),!0)}
    getComponent(t,s){return this.components.get(s).get(t)}
    hasComponent(t,s){return this.entities.has(t)&&this.entities.get(t).has(s)}
    removeComponent(t,s){this.entities.has(t)&&(this.entities.get(t).delete(s),this.components.get(s).delete(t))}
    query(t){const s=[];for(const[i,e]of this.entities)t.every(t=>e.has(t))&&s.push(i);return s}
    addSystem(t){this.systems.push(t)}
    update(t){this.systems.forEach(s=>s(this,t))}
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * MAZE GENERATION
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  function generateSolvableMaze(cols, rows) {
    const grid = Array(rows).fill(0).map(() => Array(cols).fill(0).map(() => ({ visited: false, walls: [true, true, true, true], isPath: false })));
    const stack = [];
    let current = {r: 0, c: 0};
    grid[0][0].visited = true;
    const directions = [[-1, 0, 0, 2], [0, 1, 1, 3], [1, 0, 2, 0], [0, -1, 3, 1]];
    do {
      const {r, c} = current;
      const neighbors = directions.filter(([dr, dc]) => {
        const nr = r + dr; const nc = c + dc;
        return nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].visited;
      });
      if (neighbors.length > 0) {
        const [dr, dc, wallIdx, oppositeIdx] = neighbors[Math.floor(Math.random() * neighbors.length)];
        const nr = r + dr; const nc = c + dc;
        grid[r][c].walls[wallIdx] = false;
        grid[nr][nc].visited = true;
        grid[nr][nc].walls[oppositeIdx] = false;
        stack.push(current);
        current = {r: nr, c: nc};
      } else {
        current = stack.pop();
      }
    } while (stack.length > 0);
    return { grid, start: {r: 0, c: 0}, end: {r: rows - 1, c: cols - 1} };
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * CAMERA & MINIMAP SYSTEMS
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const CameraMode={THIRD_PERSON:"third_person",FIRST_PERSON:"first_person"};class CameraSystem{constructor(t){this.camera=t,this.mode=CameraMode.THIRD_PERSON,this.targetEntity=null,this.offset=new THREE.Vector3(0,4,6),this.firstPersonOffset=new THREE.Vector3(0,.5,0),this.smoothness=.1}setTarget(t){this.targetEntity=t}toggleMode(){this.mode=this.mode===CameraMode.THIRD_PERSON?CameraMode.FIRST_PERSON:CameraMode.THIRD_PERSON,document.getElementById("camera-info").textContent=this.mode===CameraMode.THIRD_PERSON?"Third Person":"First Person"}update(t){if(!this.targetEntity)return;const s=t.getComponent(this.targetEntity,ComponentTypes.TRANSFORM);if(!s)return;const i=new THREE.Vector3(s.x,s.y,s.z);if(this.mode===CameraMode.THIRD_PERSON){const t=i.clone().add(this.offset);this.camera.position.lerp(t,this.smoothness),this.camera.lookAt(i)}else{const e=i.clone().add(this.firstPersonOffset);this.camera.position.lerp(e,2*this.smoothness);const h=t.getComponent(this.targetEntity,ComponentTypes.VELOCITY);h&&Math.abs(h.vx)>.1||Math.abs(h.vz)>.1?this.camera.lookAt(i.clone().add(new THREE.Vector3(h.vx,0,h.vz).normalize())):this.camera.lookAt(i.x,i.y,i.z-1)}}}
  class MinimapSystem{constructor(t,s,i,e){this.canvas=document.getElementById(t),this.ctx=this.canvas.getContext("2d"),this.maze=s,this.cols=i,this.rows=e,this.cellSize=this.canvas.width/Math.max(i,e),this.exploredCells=new Set,this.visible=!0,this.playerEntity=null,this.goalPos=null}setPlayer(t){this.playerEntity=t}setGoal(t){this.goalPos=t}toggle(){this.visible=!this.visible,document.getElementById("minimap-container").style.display=this.visible?"block":"none"}markExplored(t,s,i=1){for(let e=Math.max(0,t-i);e<=Math.min(this.rows-1,t+i);e++)for(let h=Math.max(0,s-i);h<=Math.min(this.cols-1,s+i);h++)this.exploredCells.add(`${e},${h}`)}update(t){if(!this.visible||!this.playerEntity)return;const s=t.getComponent(this.playerEntity,ComponentTypes.TRANSFORM);s&&(this.markExplored(Math.floor((s.z+this.rows*CELL_SIZE/2)/CELL_SIZE),Math.floor((s.x+this.cols*CELL_SIZE/2)/CELL_SIZE),1),this.render(Math.floor((s.z+this.rows*CELL_SIZE/2)/CELL_SIZE),Math.floor((s.x+this.cols*CELL_SIZE/2)/CELL_SIZE)))}render(t,s){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);for(let i=0;i<this.rows;i++)for(let e=0;e<this.cols;e++){const h=e*this.cellSize,o=i*this.cellSize;if(this.exploredCells.has(`${i},${e}`)){this.ctx.fillStyle="#333",this.ctx.fillRect(h,o,this.cellSize,this.cellSize),this.ctx.strokeStyle="#666",this.ctx.lineWidth=2,this.ctx.beginPath();const t=this.maze.grid[i][e];t.walls[0]&&(this.ctx.moveTo(h,o),this.ctx.lineTo(h+this.cellSize,o)),t.walls[1]&&(this.ctx.moveTo(h+this.cellSize,o),this.ctx.lineTo(h+this.cellSize,o+this.cellSize)),t.walls[2]&&(this.ctx.moveTo(h+this.cellSize,o+this.cellSize),this.ctx.lineTo(h,o+this.cellSize)),t.walls[3]&&(this.ctx.moveTo(h,o+this.cellSize),this.ctx.lineTo(h,o)),this.ctx.stroke()}else this.ctx.fillStyle="#111",this.ctx.fillRect(h,o,this.cellSize,this.cellSize)}if(this.goalPos&&this.exploredCells.has(`${this.goalPos.r},${this.goalPos.c}`)){const t=this.goalPos.c*this.cellSize+this.cellSize/2,s=this.goalPos.r*this.cellSize+this.cellSize/2;this.ctx.fillStyle="#00ff00",this.ctx.beginPath(),this.ctx.arc(t,s,this.cellSize/3,0,2*Math.PI),this.ctx.fill()}if(t>=0&&t<this.rows&&s>=0&&s<this.cols){const i=s*this.cellSize+this.cellSize/2,e=t*this.cellSize+this.cellSize/2;this.ctx.fillStyle="#ffff00",this.ctx.beginPath(),this.ctx.arc(i,e,this.cellSize/4,0,2*Math.PI),this.ctx.fill()}}}

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * AUDIO SYSTEM
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  class AudioSystem {
    constructor() {
      this.isMusicMuted = false;
      this.isSfxMuted = false;
      
      // FIX: Reverting to reliable URLs from the official Howler.js CDN and using audio sprites.
      this.sounds = {
        'music': new Howl({
          src: ['https://goldfirestudios.com/proj/howlerjs/sound.mp3'],
          loop: true, volume: 0.3
        }),
        'sfx': new Howl({
            src: ['https://goldfirestudios.com/proj/howlerjs/sounds.mp3'],
            sprite: {
                collision: [893, 764],
                goal: [2049, 1152]
            }
        })
      };
      this.musicStarted = false;
    }

    startMusic() {
      if (!this.musicStarted && !this.isMusicMuted) {
        this.sounds.music.play();
        this.musicStarted = true;
      }
    }

    playSound(spriteName) {
      if (!this.isSfxMuted) {
        this.sounds.sfx.play(spriteName);
      }
    }
    
    toggleMusic() {
        this.isMusicMuted = !this.isMusicMuted;
        this.sounds.music.mute(this.isMusicMuted);
        document.getElementById('toggle-music').classList.toggle('muted', this.isMusicMuted);
    }
    
    toggleSfx() {
        this.isSfxMuted = !this.isSfxMuted;
        document.getElementById('toggle-sfx').classList.toggle('muted', this.isSfxMuted);
    }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * SCENE SETUP & GAME STATE
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.05);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFShadowMap;
  document.body.appendChild(renderer.domElement);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);
  const textureLoader = new THREE.TextureLoader();
  let world, cameraSystem, minimapSystem, audioSystem;
  let COLS = 20, ROWS = 20, CELL_SIZE = 2;
  let maze, walls = [];
  let playerEntity, goalEntity;
  let gameCompleted = false;
  let physicsDebugEnabled = false;
  let lastCollisionTime = 0;

  function initializeGame() {
    world = new ECSWorld();
    maze = generateSolvableMaze(COLS, ROWS);
    cameraSystem = new CameraSystem(camera);
    minimapSystem = new MinimapSystem('minimap', maze, COLS, ROWS);
    minimapSystem.setGoal(maze.end);
    if (!audioSystem) { audioSystem = new AudioSystem(); }
    const objectsToRemove = scene.children.filter(obj => !(obj.isLight) && obj.type !== 'PerspectiveCamera');
    objectsToRemove.forEach(obj => scene.remove(obj));
    buildMazeGeometry();
    createPlayer();
    createGoal();
    cameraSystem.setTarget(playerEntity);
    minimapSystem.setPlayer(playerEntity);
    if (world.systems.length === 0) { setupSystems(); }
    gameCompleted = false;
    document.getElementById('goal-indicator').style.opacity = '0';
  }

  function buildMazeGeometry(){walls=[];const t=textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/hardwood2_diffuse.jpg");t.wrapS=THREE.RepeatWrapping;t.wrapT=THREE.RepeatWrapping;t.repeat.set(COLS,ROWS);const s=textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg");s.wrapS=THREE.RepeatWrapping;s.wrapT=THREE.RepeatWrapping;s.repeat.set(1,.5);const i=new THREE.MeshStandardMaterial({map:t,roughness:.8,metalness:.1}),e=new THREE.MeshStandardMaterial({map:s,roughness:.9,metalness:0}),h=new THREE.Mesh(new THREE.PlaneGeometry(COLS*CELL_SIZE,ROWS*CELL_SIZE),i);h.rotation.x=-Math.PI/2;h.receiveShadow=!0;scene.add(h);const o=new THREE.BoxGeometry(CELL_SIZE,1.5,.2);for(let t=0;t<ROWS;t++)for(let s=0;s<COLS;s++){const i=maze.grid[t][s],h=(s-COLS/2+.5)*CELL_SIZE,a=(t-ROWS/2+.5)*CELL_SIZE;if(i.walls[0]){const t=new THREE.Mesh(o,e.clone());t.position.set(h,.75,a-CELL_SIZE/2),t.castShadow=!0,scene.add(t),walls.push({x:h,z:a-CELL_SIZE/2,horizontal:!0})}if(i.walls[3]){const t=new THREE.Mesh(o,e.clone());t.rotation.y=Math.PI/2,t.position.set(h-CELL_SIZE/2,.75,a),t.castShadow=!0,scene.add(t),walls.push({x:h-CELL_SIZE/2,z:a,horizontal:!1})}if(t===ROWS-1&&i.walls[2]){const t=new THREE.Mesh(o,e.clone());t.position.set(h,.75,a+CELL_SIZE/2),t.castShadow=!0,scene.add(t),walls.push({x:h,z:a+CELL_SIZE/2,horizontal:!0})}if(s===COLS-1&&i.walls[1]){const t=new THREE.Mesh(o,e.clone());t.rotation.y=Math.PI/2,t.position.set(h+CELL_SIZE/2,.75,a),t.castShadow=!0,scene.add(t),walls.push({x:h+CELL_SIZE/2,z:a,horizontal:!1})}}}
  function createPlayer(){playerEntity=world.createEntity();const t=-(COLS/2-.5)*CELL_SIZE,s=-(ROWS/2-.5)*CELL_SIZE;world.addComponent(playerEntity,ComponentTypes.TRANSFORM,{x:t,y:.4,z:s});world.addComponent(playerEntity,ComponentTypes.VELOCITY,{vx:0,vz:0});world.addComponent(playerEntity,ComponentTypes.PHYSICS,{mass:1,acceleration:{x:0,z:0},maxSpeed:5,moveForce:12,friction:.88,airResistance:.92,groundFriction:.85,isGrounded:!0});world.addComponent(playerEntity,ComponentTypes.PLAYER,{});const i=new THREE.Mesh(new THREE.SphereGeometry(.3,16,16),new THREE.MeshStandardMaterial({color:16776960,emissive:4473924,emissiveIntensity:.3,roughness:.4,metalness:.1}));i.castShadow=!0;world.addComponent(playerEntity,ComponentTypes.RENDER,{mesh:i});const e=new THREE.PointLight(16777096,1.5,10);i.add(e);world.addComponent(playerEntity,ComponentTypes.LIGHT,{light:e});scene.add(i)}
  function createGoal(){goalEntity=world.createEntity();const t=(maze.end.c-COLS/2+.5)*CELL_SIZE,s=(maze.end.r-ROWS/2+.5)*CELL_SIZE;world.addComponent(goalEntity,ComponentTypes.TRANSFORM,{x:t,y:.5,z:s});world.addComponent(goalEntity,ComponentTypes.GOAL,{});const i=new THREE.Mesh(new THREE.CylinderGeometry(.4,.4,1,8),new THREE.MeshStandardMaterial({color:65280,emissive:17408,emissiveIntensity:.5}));world.addComponent(goalEntity,ComponentTypes.RENDER,{mesh:i});const e=new THREE.PointLight(65280,2,8);e.position.set(0,1,0),i.add(e),scene.add(i)}

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ECS SYSTEMS
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  function setupSystems(){
    world.addSystem((t,s)=>{const i=t.query([ComponentTypes.PLAYER,ComponentTypes.PHYSICS]);for(const e of i){const i=t.getComponent(e,ComponentTypes.PHYSICS);i.acceleration.x=0,i.acceleration.z=0;let h=0,o=0;keyState.KeyD||keyState.ArrowRight?h+=1:0,keyState.KeyA||keyState.ArrowLeft?h-=1:0,keyState.KeyS||keyState.ArrowDown?o+=1:0,keyState.KeyW||keyState.ArrowUp?o-=1:0;const a=Math.hypot(h,o);if(a>0){h/=a,o/=a;const t=i.moveForce;i.acceleration.x+=h*t/i.mass,i.acceleration.z+=o*t/i.mass}}});
    world.addSystem((t,s)=>{const i=t.query([ComponentTypes.VELOCITY,ComponentTypes.PHYSICS]);s=Math.min(s,1/30);for(const e of i){const i=t.getComponent(e,ComponentTypes.VELOCITY),h=t.getComponent(e,ComponentTypes.PHYSICS);i.vx+=h.acceleration.x*s,i.vz+=h.acceleration.z*s;const o=Math.pow(h.airResistance,10*s);i.vx*=o,i.vz*=o,h.isGrounded&&(i.vx*=Math.pow(h.groundFriction,8*s),i.vz*=Math.pow(h.groundFriction,8*s));const a=Math.hypot(i.vx,i.vz);if(a>h.maxSpeed){const t=h.maxSpeed/a;i.vx*=t,i.vz*=t}Math.abs(i.vx)<.02&&(i.vx=0),Math.abs(i.vz)<.02&&(i.vz=0)}});
    // FIX: Calling playSound with the correct sprite name.
    world.addSystem((t,s)=>{const i=t.query([ComponentTypes.TRANSFORM,ComponentTypes.VELOCITY]);for(const e of i){const i=t.getComponent(e,ComponentTypes.TRANSFORM),h=t.getComponent(e,ComponentTypes.VELOCITY),o=i.x+h.vx*s,a=i.z+h.vz*s,n=()=>{const s=performance.now();s-lastCollisionTime>200&&(audioSystem.playSound("collision"),lastCollisionTime=s)};checkCollision(o,i.z)?(h.vx*=-.1,t.hasComponent(e,ComponentTypes.PLAYER)&&n()):i.x=o,checkCollision(i.x,a)?(h.vz*=-.1,t.hasComponent(e,ComponentTypes.PLAYER)&&n()):i.z=a}});
    world.addSystem((t,s)=>{const i=t.query([ComponentTypes.TRANSFORM,ComponentTypes.RENDER]);for(const e of i){const i=t.getComponent(e,ComponentTypes.TRANSFORM),h=t.getComponent(e,ComponentTypes.RENDER);if(h.mesh){h.mesh.position.set(i.x,i.y,i.z);if(t.hasComponent(e,ComponentTypes.PLAYER)){const i=t.getComponent(e,ComponentTypes.VELOCITY);h.mesh.rotation.x+=i.vz*s*.5,h.mesh.rotation.z-=.5*i.vx*s}}}});
    // FIX: Calling playSound with the correct sprite name.
    world.addSystem((t,s)=>{if(gameCompleted)return;const i=t.query([ComponentTypes.PLAYER,ComponentTypes.TRANSFORM]),e=t.query([ComponentTypes.GOAL,ComponentTypes.TRANSFORM]);for(const h of i){const i=t.getComponent(h,ComponentTypes.TRANSFORM);for(const o of e){const e=t.getComponent(o,ComponentTypes.TRANSFORM),a=Math.hypot(i.x-e.x,i.z-e.z);a<1&&(gameCompleted=!0,audioSystem.playSound("goal"),document.getElementById("goal-indicator").style.opacity="1",setTimeout(()=>{initializeGame()},3e3))}}});
    world.addSystem((t,s)=>{if(!physicsDebugEnabled)return;const i=t.query([ComponentTypes.PLAYER,ComponentTypes.VELOCITY,ComponentTypes.PHYSICS]);for(const e of i){const i=t.getComponent(e,ComponentTypes.VELOCITY),h=t.getComponent(e,ComponentTypes.PHYSICS),o=Math.hypot(i.vx,i.vz);document.getElementById("debug-speed").textContent=o.toFixed(2),document.getElementById("debug-vx").textContent=i.vx.toFixed(2),document.getElementById("debug-vz").textContent=i.vz.toFixed(2),document.getElementById("debug-ax").textContent=h.acceleration.x.toFixed(2),document.getElementById("debug-az").textContent=h.acceleration.z.toFixed(2);let a=0,n=0;keyState.KeyD||keyState.ArrowRight?a=1:0,keyState.KeyA||keyState.ArrowLeft?a=-1:0,keyState.KeyS||keyState.ArrowDown?n=1:0,keyState.KeyW||keyState.ArrowUp?n=-1:0,document.getElementById("debug-ix").textContent=a,document.getElementById("debug-iz").textContent=n;break}});}
  function checkCollision(x,z,radius=.3){const buffer=.1;if(x<-COLS*CELL_SIZE/2+radius||x>COLS*CELL_SIZE/2-radius||z<-ROWS*CELL_SIZE/2+radius||z>ROWS*CELL_SIZE/2-radius)return!0;for(const wall of walls){const dx=Math.abs(x-wall.x),dz=Math.abs(z-wall.z);if(wall.horizontal){if(dz<radius+buffer&&dx<CELL_SIZE/2+radius)return!0}else if(dx<radius+buffer&&dz<CELL_SIZE/2+radius)return!0}return!1}

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * INPUT HANDLING (No Changes)
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const keyState = {};
  window.addEventListener('keydown', (e) => {
    if (audioSystem) { audioSystem.startMusic(); }
    keyState[e.code] = true;
    if (document.activeElement === document.body) {
        if (e.code === 'KeyC') { cameraSystem.toggleMode(); }
        else if (e.code === 'KeyM') { minimapSystem.toggle(); }
        else if (e.code === 'KeyR') { initializeGame(); }
        else if (e.code === 'KeyP') {
            physicsDebugEnabled = !physicsDebugEnabled;
            document.getElementById('physics-debug').style.display = physicsDebugEnabled ? 'block' : 'none';
        }
        else if (e.code === 'KeyJ') { if (audioSystem) audioSystem.toggleMusic(); }
        else if (e.code === 'KeyK') { if (audioSystem) audioSystem.toggleSfx(); }
    }
  });
  window.addEventListener('keyup', (e) => { keyState[e.code] = false; });
  window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  document.getElementById('toggle-music').addEventListener('click', () => { if (audioSystem) audioSystem.toggleMusic(); });
  document.getElementById('toggle-sfx').addEventListener('click', () => { if (audioSystem) audioSystem.toggleSfx(); });

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * MAIN GAME LOOP (No Changes)
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  let lastTime = performance.now();
  function gameLoop(currentTime) {
    requestAnimationFrame(gameLoop);
    const rawDeltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    const deltaTime = Math.min(rawDeltaTime, 1/30); 
    if (world) { world.update(deltaTime); }
    if (cameraSystem) { cameraSystem.update(world); }
    if (minimapSystem) { minimapSystem.update(world); }
    renderer.render(scene, camera);
  }

  // Initialize and start the game
  initializeGame();
  gameLoop(lastTime);
  console.log("ðŸŽ® Advanced Physics-Based Maze Game Loaded! V2.6 with Audio Fixed.");

} catch (error) {
  console.error("Failed to initialize maze game:", error);
  document.body.innerHTML = `<div style="color:white;text-align:center;margin-top:50px;font-family:Arial;"><h2>Failed to initialize maze game</h2><p>Error: ${error.message}</p><p>Please check the browser console for more details.</p></div>`;
}
</script>
</body>
</html>
