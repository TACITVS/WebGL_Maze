<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Procedural Maze Â· Wall Sliding</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:'Arial',sans-serif;}
    canvas{display:block}
    
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 100;
      color: #fff;
    }
    
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      pointer-events: auto;
      font-size: 14px;
      max-width: 250px;
    }

    #hud {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 30px;
        background: rgba(0,0,0,0.7);
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 22px;
        font-weight: bold;
        text-shadow: 1px 1px 2px #000;
    }
    
    #minimap-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      border: 3px solid #444;
      border-radius: 8px;
      background: rgba(0,0,0,0.9);
      pointer-events: auto;
    }
    
    #minimap {
      display: block;
      border-radius: 5px;
    }
    
    #camera-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
    }
    
    #goal-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff00;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    #physics-debug {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      display: none;
    }
    .control-key {
      background: rgba(255,255,255,0.2);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      cursor: pointer;
      display: inline-block;
      min-width: 12px;
      text-align: center;
    }
    .muted {
        text-decoration: line-through;
        opacity: 0.5;
    }
  </style>
</head>
<body>
<div id="ui">
  <div id="hud">
    <div>Time: <span id="timer">00:00</span></div>
    <div>Score: <span id="score">0</span></div>
  </div>

  <div id="controls">
    <div><strong>ðŸŽ® Controls</strong></div>
    <div><span class="control-key">WASD</span> / <span class="control-key">Arrows</span> - Move</div>
    <div><span class="control-key">C</span> - Switch Camera</div>
    <div><span class="control-key">M</span> - Toggle Minimap</div>
    <div><span class="control-key">R</span> - New Maze</div>
    <div><span class="control-key">P</span> - Physics Debug</div>
    
    <div style="margin-top:10px;"><strong>ðŸ”Š Audio</strong></div>
    <div><span class="control-key" id="toggle-music">J</span> - Music</div>
    <div><span class="control-key" id="toggle-sfx">K</span> - SFX</div>

    <div style="margin-top:10px;"><strong>ðŸŽ¯ Goal:</strong> Find the green exit!</div>
    <div style="margin-top:5px;font-size:11px;opacity:0.8;">
      <em>Collect coins for more points!</em>
    </div>
  </div>
  
  <div id="camera-info">Third Person</div>
  
  <div id="minimap-container">
    <canvas id="minimap" width="200" height="200"></canvas>
  </div>
  
  <div id="goal-indicator">ðŸŽ‰ MAZE COMPLETED! ðŸŽ‰</div>
  
  <div id="physics-debug">
    <div><strong>Physics Debug</strong></div>
    <div>Speed: <span id="debug-speed">0.00</span> m/s</div>
    <div>Velocity: (<span id="debug-vx">0.00</span>, <span id="debug-vz">0.00</span>)</div>
    <div>Accel: (<span id="debug-ax">0.00</span>, <span id="debug-az">0.00</span>)</div>
    <div>Input: (<span id="debug-ix">0</span>, <span id="debug-iz">0</span>)</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<script>
try {
  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ECS ARCHITECTURE
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const ComponentTypes = { 
    TRANSFORM: 'transform', VELOCITY: 'velocity', PHYSICS: 'physics', RENDER: 'render', PLAYER: 'player', 
    GOAL: 'goal', LIGHT: 'light', COLLECTIBLE: 'collectible'
  };

  class ECSWorld {
    constructor() {
      this.entities = new Map();
      this.components = new Map();
      this.systems = [];
      this.nextEntityId = 1;
      
      Object.values(ComponentTypes).forEach(type => {
        this.components.set(type, new Map());
      });
    }
    
    createEntity() {
      const id = this.nextEntityId++;
      this.entities.set(id, new Set());
      return id;
    }
    
    addComponent(entityId, componentType, data = {}) {
      if (!this.entities.has(entityId)) return false;
      this.entities.get(entityId).add(componentType);
      this.components.get(componentType).set(entityId, data);
      return true;
    }
    
    getComponent(entityId, componentType) {
      return this.components.get(componentType).get(entityId);
    }
    
    hasComponent(entityId, componentType) {
      return this.entities.has(entityId) && this.entities.get(entityId).has(componentType);
    }
    
    removeComponent(entityId, componentType) {
        if (!this.hasComponent(entityId, componentType)) return;
        this.entities.get(entityId).delete(componentType);
        this.components.get(componentType).delete(entityId);
    }

    removeEntity(entityId) {
        if (!this.entities.has(entityId)) return;
        this.entities.get(entityId).forEach(componentType => {
            this.removeComponent(entityId, componentType);
        });
        this.entities.delete(entityId);
    }
    
    query(componentTypes) {
      const results = [];
      for (const [entityId, entityComponents] of this.entities) {
        if (componentTypes.every(type => entityComponents.has(type))) {
          results.push(entityId);
        }
      }
      return results;
    }
    
    addSystem(systemFunction) {
      this.systems.push(systemFunction);
    }
    
    update(deltaTime) {
      this.systems.forEach(system => system(this, deltaTime));
    }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * MAZE GENERATION
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  function generateSolvableMaze(cols, rows) {
    const grid = Array(rows).fill(0).map(() => Array(cols).fill(0).map(() => ({ visited: false, walls: [true, true, true, true], isPath: false })));
    const stack = [];
    let current = {r: 0, c: 0};
    grid[0][0].visited = true;
    const directions = [[-1, 0, 0, 2], [0, 1, 1, 3], [1, 0, 2, 0], [0, -1, 3, 1]];
    
    do {
      const {r, c} = current;
      const neighbors = directions.filter(([dr, dc]) => {
        const nr = r + dr;
        const nc = c + dc;
        return nr >= 0 && nr < rows && nc >= 0 && nc < cols && !grid[nr][nc].visited;
      });
      
      if (neighbors.length > 0) {
        const [dr, dc, wallIdx, oppositeIdx] = neighbors[Math.floor(Math.random() * neighbors.length)];
        const nr = current.r + dr;
        const nc = current.c + dc;
        
        grid[current.r][current.c].walls[wallIdx] = false;
        grid[nr][nc].visited = true;
        grid[nr][nc].walls[oppositeIdx] = false;
        
        stack.push(current);
        current = {r: nr, c: nc};
      } else {
        current = stack.pop();
      }
    } while (stack.length > 0);
    
    return { grid, start: {r: 0, c: 0}, end: {r: rows - 1, c: cols - 1} };
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * CAMERA & MINIMAP SYSTEMS
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const CameraMode = {THIRD_PERSON:"third_person",FIRST_PERSON:"first_person"};
  class CameraSystem {
    constructor(camera){
        this.camera=camera;
        this.mode=CameraMode.THIRD_PERSON;
        this.targetEntity=null;
        this.offset=new THREE.Vector3(0,4,6);
        this.firstPersonOffset=new THREE.Vector3(0,.5,0);
        this.smoothness=.1
    }
    setTarget(e){this.targetEntity=e}
    toggleMode(){this.mode=this.mode===CameraMode.THIRD_PERSON?CameraMode.FIRST_PERSON:CameraMode.THIRD_PERSON;document.getElementById("camera-info").textContent=this.mode===CameraMode.THIRD_PERSON?"Third Person":"First Person"}
    update(e){
        if(!this.targetEntity)return;
        const t=e.getComponent(this.targetEntity,ComponentTypes.TRANSFORM);
        if(!t)return;
        const s=new THREE.Vector3(t.x,t.y,t.z);
        if(this.mode===CameraMode.THIRD_PERSON){
            const e=s.clone().add(this.offset);
            this.camera.position.lerp(e,this.smoothness);
            this.camera.lookAt(s)
        } else {
            const i=s.clone().add(this.firstPersonOffset);
            this.camera.position.lerp(i,2*this.smoothness);
            const r=e.getComponent(this.targetEntity,ComponentTypes.VELOCITY);
            if(r&&(Math.abs(r.vx)>.1||Math.abs(r.vz)>.1)){
                this.camera.lookAt(s.clone().add(new THREE.Vector3(r.vx,0,r.vz).normalize()))
            } else {
                this.camera.lookAt(s.x,s.y,s.z-1)
            }
        }
    }
  }
  
  class MinimapSystem {
    constructor(canvasId,maze,cols,rows){
        this.canvas=document.getElementById(canvasId);
        this.ctx=this.canvas.getContext("2d");
        this.maze=maze;
        this.cols=cols;
        this.rows=rows;
        this.cellSize=this.canvas.width/Math.max(cols,rows);
        this.exploredCells=new Set;
        this.visible=!0;
        this.playerEntity=null;
        this.goalPos=null
    }
    setPlayer(e){this.playerEntity=e}
    setGoal(e){this.goalPos=e}
    toggle(){this.visible=!this.visible;document.getElementById("minimap-container").style.display=this.visible?"block":"none"}
    markExplored(e,t,s=1){for(let i=Math.max(0,e-s);i<=Math.min(this.rows-1,e+s);i++)for(let r=Math.max(0,t-s);r<=Math.min(this.cols-1,t+s);r++)this.exploredCells.add(`${i},${r}`)}
    update(e){
        if(!this.visible||!this.playerEntity)return;
        const t=e.getComponent(this.playerEntity,ComponentTypes.TRANSFORM);
        if(t){
            this.markExplored(Math.floor((t.z+this.rows*CELL_SIZE/2)/CELL_SIZE),Math.floor((t.x+this.cols*CELL_SIZE/2)/CELL_SIZE),1);
            this.render(Math.floor((t.z+this.rows*CELL_SIZE/2)/CELL_SIZE),Math.floor((t.x+this.cols*CELL_SIZE/2)/CELL_SIZE))
        }
    }
    render(e,t){
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        for(let s=0;s<this.rows;s++){
            for(let i=0;i<this.cols;i++){
                const r=i*this.cellSize,o=s*this.cellSize;
                if(this.exploredCells.has(`${s},${i}`)){
                    this.ctx.fillStyle="#333";
                    this.ctx.fillRect(r,o,this.cellSize,this.cellSize);
                    this.ctx.strokeStyle="#666";
                    this.ctx.lineWidth=2;
                    this.ctx.beginPath();
                    const e=this.maze.grid[s][i];
                    if(e.walls[0]){this.ctx.moveTo(r,o);this.ctx.lineTo(r+this.cellSize,o)}
                    if(e.walls[1]){this.ctx.moveTo(r+this.cellSize,o);this.ctx.lineTo(r+this.cellSize,o+this.cellSize)}
                    if(e.walls[2]){this.ctx.moveTo(r+this.cellSize,o+this.cellSize);this.ctx.lineTo(r,o+this.cellSize)}
                    if(e.walls[3]){this.ctx.moveTo(r,o+this.cellSize);this.ctx.lineTo(r,o)}
                    this.ctx.stroke()
                } else {
                    this.ctx.fillStyle="#111";
                    this.ctx.fillRect(r,o,this.cellSize,this.cellSize)
                }
            }
        }
        if(this.goalPos&&this.exploredCells.has(`${this.goalPos.r},${this.goalPos.c}`)){
            const e=this.goalPos.c*this.cellSize+this.cellSize/2,t=this.goalPos.r*this.cellSize+this.cellSize/2;
            this.ctx.fillStyle="#00ff00";
            this.ctx.beginPath();
            this.ctx.arc(e,t,this.cellSize/3,0,2*Math.PI);
            this.ctx.fill()
        }
        if(e>=0&&e<this.rows&&t>=0&&t<this.cols){
            const s=t*this.cellSize+this.cellSize/2,i=e*this.cellSize+this.cellSize/2;
            this.ctx.fillStyle="#ffff00";
            this.ctx.beginPath();
            this.ctx.arc(s,i,this.cellSize/4,0,2*Math.PI);
            this.ctx.fill()
        }
    }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * AUDIO SYSTEM
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  class AudioSystem {
    constructor(){
        this.isMusicMuted=false;
        this.isSfxMuted=false;
        this.sounds={
            music:new Howl({src:["https://goldfirestudios.com/proj/howlerjs/sound.mp3"],loop:true,volume:.3}),
            sfx:new Howl({src:["https://goldfirestudios.com/proj/howlerjs/sounds.mp3"],
            sprite:{collision:[893,764],goal:[2049,1152],collect:[3500,450]}})
        };
        this.musicStarted=false
    }
    startMusic(){
        if(!this.musicStarted&&!this.isMusicMuted){
            this.sounds.music.play();
            this.musicStarted=true
        }
    }
    playSound(e){
        if(!this.isSfxMuted){this.sounds.sfx.play(e)}
    }
    toggleMusic(){
        this.isMusicMuted=!this.isMusicMuted;
        this.sounds.music.mute(this.isMusicMuted);
        document.getElementById("toggle-music").classList.toggle("muted",this.isMusicMuted)
    }
    toggleSfx(){
        this.isSfxMuted=!this.isSfxMuted;
        document.getElementById("toggle-sfx").classList.toggle("muted",this.isSfxMuted)
    }
  }

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * SCENE SETUP & GAME STATE
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.05);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFShadowMap;
  document.body.appendChild(renderer.domElement);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);
  const textureLoader = new THREE.TextureLoader();
  let world, cameraSystem, minimapSystem, audioSystem;
  let COLS = 20, ROWS = 20, CELL_SIZE = 2;
  let maze, walls = [];
  let playerEntity, goalEntity;
  let gameCompleted = false;
  let physicsDebugEnabled = false;
  let lastCollisionTime = 0;
  let score = 0;
  let gameTime = 0;
  let levelStartTime = 0;

  function initializeGame() {
    world = new ECSWorld();
    maze = generateSolvableMaze(COLS, ROWS);
    cameraSystem = new CameraSystem(camera);
    minimapSystem = new MinimapSystem('minimap', maze, COLS, ROWS);
    minimapSystem.setGoal(maze.end);
    if (!audioSystem) { audioSystem = new AudioSystem(); }
    const objectsToRemove = scene.children.filter(obj => !(obj.isLight) && obj.type !== 'PerspectiveCamera');
    objectsToRemove.forEach(obj => scene.remove(obj));
    buildMazeGeometry();
    createPlayer();
    createGoal();
    createCollectibles(10);
    
    cameraSystem.setTarget(playerEntity);
    minimapSystem.setPlayer(playerEntity);
    if (world.systems.length === 0) { setupSystems(); }
    
    gameCompleted = false;
    score = 0;
    levelStartTime = performance.now();
    document.getElementById('goal-indicator').style.opacity = '0';
    document.getElementById('score').textContent = score;
  }

  function buildMazeGeometry() {
    walls = [];
    const floorTexture = textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/hardwood2_diffuse.jpg");
    floorTexture.wrapS = THREE.RepeatWrapping;
    floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(COLS, ROWS);
    const wallTexture = textureLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg");
    wallTexture.wrapS = THREE.RepeatWrapping;
    wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(1, 0.5);
    const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, roughness: 0.8, metalness: 0.1 });
    const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.9, metalness: 0.0 });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(COLS * CELL_SIZE, ROWS * CELL_SIZE), floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);
    const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, 1.5, 0.2);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cell = maze.grid[r][c];
        const x = (c - COLS / 2 + 0.5) * CELL_SIZE;
        const z = (r - ROWS / 2 + 0.5) * CELL_SIZE;
        if (cell.walls[0]) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
          wall.position.set(x, 0.75, z - CELL_SIZE / 2);
          wall.castShadow = true;
          scene.add(wall);
          walls.push({ x: x, z: z - CELL_SIZE / 2, horizontal: true });
        }
        if (cell.walls[3]) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
          wall.rotation.y = Math.PI / 2;
          wall.position.set(x - CELL_SIZE / 2, 0.75, z);
          wall.castShadow = true;
          scene.add(wall);
          walls.push({ x: x - CELL_SIZE / 2, z: z, horizontal: false });
        }
        if (r === ROWS - 1 && cell.walls[2]) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
          wall.position.set(x, 0.75, z + CELL_SIZE / 2);
          wall.castShadow = true;
          scene.add(wall);
          walls.push({ x: x, z: z + CELL_SIZE / 2, horizontal: true });
        }
        if (c === COLS - 1 && cell.walls[1]) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
          wall.rotation.y = Math.PI / 2;
          wall.position.set(x + CELL_SIZE / 2, 0.75, z);
          wall.castShadow = true;
          scene.add(wall);
          walls.push({ x: x + CELL_SIZE / 2, z: z, horizontal: false });
        }
      }
    }
  }

  function createPlayer() {
    playerEntity = world.createEntity();
    const startX = -(COLS / 2 - 0.5) * CELL_SIZE;
    const startZ = -(ROWS / 2 - 0.5) * CELL_SIZE;
    world.addComponent(playerEntity, ComponentTypes.TRANSFORM, { x: startX, y: 0.4, z: startZ });
    world.addComponent(playerEntity, ComponentTypes.VELOCITY, { vx: 0, vz: 0 });
    world.addComponent(playerEntity, ComponentTypes.PHYSICS, { mass: 1, acceleration: { x: 0, z: 0 }, maxSpeed: 5, moveForce: 12, friction: 0.88, airResistance: 0.92, groundFriction: 0.85, isGrounded: true });
    world.addComponent(playerEntity, ComponentTypes.PLAYER, {});
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0x444400, emissiveIntensity: 0.3, roughness: 0.4, metalness: 0.1 }));
    mesh.castShadow = true;
    world.addComponent(playerEntity, ComponentTypes.RENDER, { mesh: mesh });
    const light = new THREE.PointLight(0xffff88, 1.5, 10);
    mesh.add(light);
    world.addComponent(playerEntity, ComponentTypes.LIGHT, { light: light });
    scene.add(mesh);
  }

  function createGoal() {
    goalEntity = world.createEntity();
    const goalX = (maze.end.c - COLS / 2 + 0.5) * CELL_SIZE;
    const goalZ = (maze.end.r - ROWS / 2 + 0.5) * CELL_SIZE;
    world.addComponent(goalEntity, ComponentTypes.TRANSFORM, { x: goalX, y: 0.5, z: goalZ });
    world.addComponent(goalEntity, ComponentTypes.GOAL, {});
    const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1, 8), new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x004400, emissiveIntensity: 0.5 }));
    world.addComponent(goalEntity, ComponentTypes.RENDER, { mesh: mesh });
    const light = new THREE.PointLight(0x00ff00, 2, 8);
    light.position.set(0, 1, 0);
    mesh.add(light);
    scene.add(mesh);
  }

  function createCollectibles(count) {
    const geometry = new THREE.SphereGeometry(0.15, 8, 8);
    const material = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xccab00, metalness: 0.6, roughness: 0.2 });
    for (let i = 0; i < count; i++) {
      const collectibleId = world.createEntity();
      let r, c;
      do {
        r = Math.floor(Math.random() * ROWS);
        c = Math.floor(Math.random() * COLS);
      } while ((r === 0 && c === 0) || (r === ROWS - 1 && c === COLS - 1));
      const x = (c - COLS / 2 + 0.5) * CELL_SIZE;
      const z = (r - ROWS / 2 + 0.5) * CELL_SIZE;
      world.addComponent(collectibleId, ComponentTypes.TRANSFORM, { x: x, y: 0.4, z: z });
      const mesh = new THREE.Mesh(geometry, material);
      world.addComponent(collectibleId, ComponentTypes.RENDER, { mesh: mesh });
      world.addComponent(collectibleId, ComponentTypes.COLLECTIBLE, { value: 100 });
      scene.add(mesh);
    }
  }
  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ECS SYSTEMS
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  function setupSystems() {
    world.addSystem((world, deltaTime) => {
      const players = world.query([ComponentTypes.PLAYER, ComponentTypes.PHYSICS]);
      for (const entityId of players) {
        const physics = world.getComponent(entityId, ComponentTypes.PHYSICS);
        physics.acceleration.x = 0;
        physics.acceleration.z = 0;
        let inputX = 0, inputZ = 0;
        if (keyState['KeyD'] || keyState['ArrowRight']) inputX += 1;
        if (keyState['KeyA'] || keyState['ArrowLeft']) inputX -= 1;
        if (keyState['KeyS'] || keyState['ArrowDown']) inputZ += 1;
        if (keyState['KeyW'] || keyState['ArrowUp']) inputZ -= 1;
        const inputLength = Math.hypot(inputX, inputZ);
        if (inputLength > 0) {
          inputX /= inputLength;
          inputZ /= inputLength;
          const force = physics.moveForce;
          physics.acceleration.x += (inputX * force) / physics.mass;
          physics.acceleration.z += (inputZ * force) / physics.mass;
        }
      }
    });

    world.addSystem((world, deltaTime) => {
      const physicsEntities = world.query([ComponentTypes.VELOCITY, ComponentTypes.PHYSICS]);
      deltaTime = Math.min(deltaTime, 1 / 30);
      for (const entityId of physicsEntities) {
        const velocity = world.getComponent(entityId, ComponentTypes.VELOCITY);
        const physics = world.getComponent(entityId, ComponentTypes.PHYSICS);
        velocity.vx += physics.acceleration.x * deltaTime;
        velocity.vz += physics.acceleration.z * deltaTime;
        const frictionFactor = Math.pow(physics.airResistance, deltaTime * 10);
        velocity.vx *= frictionFactor;
        velocity.vz *= frictionFactor;
        if (physics.isGrounded) {
          const groundFrictionFactor = Math.pow(physics.groundFriction, deltaTime * 8);
          velocity.vx *= groundFrictionFactor;
          velocity.vz *= groundFrictionFactor;
        }
        const currentSpeed = Math.hypot(velocity.vx, velocity.vz);
        if (currentSpeed > physics.maxSpeed) {
          const scale = physics.maxSpeed / currentSpeed;
          velocity.vx *= scale;
          velocity.vz *= scale;
        }
        if (Math.abs(velocity.vx) < 0.02) velocity.vx = 0;
        if (Math.abs(velocity.vz) < 0.02) velocity.vz = 0;
      }
    });

    world.addSystem((world, deltaTime) => {
        const movableEntities = world.query([ComponentTypes.TRANSFORM, ComponentTypes.VELOCITY, ComponentTypes.PLAYER]);
        for (const entityId of movableEntities) {
            const transform = world.getComponent(entityId, ComponentTypes.TRANSFORM);
            const velocity = world.getComponent(entityId, ComponentTypes.VELOCITY);
            const oldX = transform.x;
            const oldZ = transform.z;
            const velX = velocity.vx;
            const velZ = velocity.vz;

            transform.x += velX * deltaTime;
            if (checkCollision(transform.x, oldZ)) {
                transform.x = oldX;
                velocity.vx = 0;
                if (Math.abs(velX) > 1.0) {
                    audioSystem.playSound('collision');
                }
            }
            transform.z += velZ * deltaTime;
            if (checkCollision(transform.x, transform.z)) {
                transform.z = oldZ;
                velocity.vz = 0;
                if (Math.abs(velZ) > 1.0) {
                    audioSystem.playSound('collision');
                }
            }
        }
    });

    world.addSystem((world, deltaTime) => {
      const renderableEntities = world.query([ComponentTypes.TRANSFORM, ComponentTypes.RENDER]);
      for (const entityId of renderableEntities) {
        const transform = world.getComponent(entityId, ComponentTypes.TRANSFORM);
        const render = world.getComponent(entityId, ComponentTypes.RENDER);
        if (render.mesh) {
          render.mesh.position.set(transform.x, transform.y, transform.z);
          if (world.hasComponent(entityId, ComponentTypes.PLAYER)) {
            const velocity = world.getComponent(entityId, ComponentTypes.VELOCITY);
            render.mesh.rotation.x += velocity.vz * deltaTime * 0.5;
            render.mesh.rotation.z -= velocity.vx * deltaTime * 0.5;
          }
        }
      }
    });

    world.addSystem((world) => {
        if (gameCompleted) return;
        const player = world.query([ComponentTypes.PLAYER, ComponentTypes.TRANSFORM])[0];
        if (!player) return;
        
        const playerTransform = world.getComponent(player, ComponentTypes.TRANSFORM);
        const collectibles = world.query([ComponentTypes.COLLECTIBLE, ComponentTypes.TRANSFORM, ComponentTypes.RENDER]);

        for (const collectibleId of collectibles) {
            const collectibleTransform = world.getComponent(collectibleId, ComponentTypes.TRANSFORM);
            const distance = Math.hypot(playerTransform.x - collectibleTransform.x, playerTransform.z - collectibleTransform.z);

            if (distance < 0.5) {
                const collectibleData = world.getComponent(collectibleId, ComponentTypes.COLLECTIBLE);
                score += collectibleData.value;
                document.getElementById('score').textContent = score;
                
                audioSystem.playSound('collect');

                const render = world.getComponent(collectibleId, ComponentTypes.RENDER);
                scene.remove(render.mesh);
                world.removeEntity(collectibleId);
            }
        }
    });

    world.addSystem((world, deltaTime) => {
      if (gameCompleted) return;
      const players = world.query([ComponentTypes.PLAYER, ComponentTypes.TRANSFORM]);
      const goals = world.query([ComponentTypes.GOAL, ComponentTypes.TRANSFORM]);
      for (const playerId of players) {
        const playerTransform = world.getComponent(playerId, ComponentTypes.TRANSFORM);
        for (const goalId of goals) {
          const goalTransform = world.getComponent(goalId, ComponentTypes.TRANSFORM);
          const distance = Math.hypot(playerTransform.x - goalTransform.x, playerTransform.z - goalTransform.z);
          if (distance < 1) {
            gameCompleted = true;
            const timeBonus = Math.max(0, 10000 - Math.floor(gameTime * 10));
            score += timeBonus;
            document.getElementById('score').textContent = score;

            audioSystem.playSound('goal');
            document.getElementById('goal-indicator').style.opacity = '1';
            setTimeout(() => {
              initializeGame();
            }, 3000);
          }
        }
      }
    });
    
    world.addSystem((world, deltaTime) => {
      if (gameCompleted) return;
      gameTime = (performance.now() - levelStartTime) / 1000;
      const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
      const seconds = Math.floor(gameTime % 60).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${minutes}:${seconds}`;
    });

    world.addSystem((world, deltaTime) => {
      if (!physicsDebugEnabled) return;
      const players = world.query([ComponentTypes.PLAYER, ComponentTypes.VELOCITY, ComponentTypes.PHYSICS]);
      for (const playerId of players) {
        const velocity = world.getComponent(playerId, ComponentTypes.VELOCITY);
        const physics = world.getComponent(playerId, ComponentTypes.PHYSICS);
        const speed = Math.hypot(velocity.vx, velocity.vz);
        document.getElementById('debug-speed').textContent = speed.toFixed(2);
        document.getElementById('debug-vx').textContent = velocity.vx.toFixed(2);
        document.getElementById('debug-vz').textContent = velocity.vz.toFixed(2);
        document.getElementById('debug-ax').textContent = physics.acceleration.x.toFixed(2);
        document.getElementById('debug-az').textContent = physics.acceleration.z.toFixed(2);
        let inputX = 0, inputZ = 0;
        if (keyState['KeyD'] || keyState['ArrowRight']) inputX = 1;
        if (keyState['KeyA'] || keyState['ArrowLeft']) inputX = -1;
        if (keyState['KeyS'] || keyState['ArrowDown']) inputZ = 1;
        if (keyState['KeyW'] || keyState['ArrowUp']) inputZ = -1;
        document.getElementById('debug-ix').textContent = inputX;
        document.getElementById('debug-iz').textContent = inputZ;
        break;
      }
    });
  }

  function checkCollision(x,z,radius=.3){const buffer=.1;if(x<-COLS*CELL_SIZE/2+radius||x>COLS*CELL_SIZE/2-radius||z<-ROWS*CELL_SIZE/2+radius||z>ROWS*CELL_SIZE/2-radius)return!0;for(const wall of walls){const dx=Math.abs(x-wall.x),dz=Math.abs(z-wall.z);if(wall.horizontal){if(dz<radius+buffer&&dx<CELL_SIZE/2+radius)return!0}else if(dx<radius+buffer&&dz<CELL_SIZE/2+radius)return!0}return!1}

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * INPUT HANDLING
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  const keyState = {};
  window.addEventListener('keydown', (e) => {
    if (audioSystem) { audioSystem.startMusic(); }
    keyState[e.code] = true;
    if (document.activeElement === document.body) {
        if (e.code === 'KeyC') { cameraSystem.toggleMode(); }
        else if (e.code === 'KeyM') { minimapSystem.toggle(); }
        else if (e.code === 'KeyR') { initializeGame(); }
        else if (e.code === 'KeyP') {
            physicsDebugEnabled = !physicsDebugEnabled;
            document.getElementById('physics-debug').style.display = physicsDebugEnabled ? 'block' : 'none';
        }
        else if (e.code === 'KeyJ') { if (audioSystem) audioSystem.toggleMusic(); }
        else if (e.code === 'KeyK') { if (audioSystem) audioSystem.toggleSfx(); }
    }
  });
  window.addEventListener('keyup', (e) => { keyState[e.code] = false; });
  window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  document.getElementById('toggle-music').addEventListener('click', () => { if (audioSystem) audioSystem.toggleMusic(); });
  document.getElementById('toggle-sfx').addEventListener('click', () => { if (audioSystem) audioSystem.toggleSfx(); });

  /***** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * MAIN GAME LOOP
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  
  let lastTime = performance.now();
  function gameLoop(currentTime) {
    requestAnimationFrame(gameLoop);
    const rawDeltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    const deltaTime = Math.min(rawDeltaTime, 1/30); 
    if (world) { world.update(deltaTime); }
    if (cameraSystem) { cameraSystem.update(world); }
    if (minimapSystem) { minimapSystem.update(world); }
    renderer.render(scene, camera);
  }

  // Initialize and start the game
  initializeGame();
  gameLoop(lastTime);
  console.log("ðŸŽ® Advanced Physics-Based Maze Game Loaded! V4 with Wall Sliding.");

} catch (error) {
  console.error("Failed to initialize maze game:", error);
  document.body.innerHTML = `<div style="color:white;text-align:center;margin-top:50px;font-family:Arial;"><h2>Failed to initialize maze game</h2><p>Error: ${error.message}</p><p>Please check the browser console for more details.</p></div>`;
}
</script>
</body>
</html>
